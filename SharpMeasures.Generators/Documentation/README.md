# The SharpMeasures Source Generator

> The actual API is currently only documented through XML documentation on the actual C# types. To learn how to use the generator, a good place to start might be the definitions in SharpMeasures, found [here](https://github.com/ErikWe/sharp-measures/tree/main/SharpMeasures/SharpMeasures).

### Articles
* [Installation](Installation.md)
* [Configuring the generator](Configuration.md)
* [Injecting XML documentation](DocumentationInjection.md)

# Introduction

[SharpMeasures](https://github.com/ErikWe/sharp-measures) is a C# library that aims to encourage explicit usage of physical quantities and units of measurement during development. This is done by providing concrete types, such as `Time`, `UnitOfLength`, and `Acceleration3`. The vast majority of these types are auto-generated by a source generator. This means that it's trivial to extend the existing set of quantities and units, or to make your own set entirely from scratch.

### Specialized Types

The goal is for SharpMeasures to include only the most common quantites. However, you might prefer your method signature to consist of `Altitude` rather than the terribly ambiguous `Height`. This can easily be accomplished using the source generator:

```csharp
using SharpMeasures.Generators;

[SpecializedScalarQuantity(typeof(Height))]
public partial class Altitude { }
```

This means that `Altitude` will borrow the definition from `Height` - including units, operations, and constants. Cast operators ensure that `Altitude` can implicitly be used in place of `Height` - while the reverse action would require an explicit cast.

> Caveat: Any functionality manually added to `Height` will not be present in `Altitude`. Custom functionality that should be passed on to specialized types need to be defined using `QuantityProcessAttribute`.

### New Types

The source generator can also be used to generate entirely new quantities and units:

```csharp
using SharpMeasures.Generators;

[QuantityOperation(typeof(Area), typeof(Length), OperatorType.Multiplication)]
[ScalarQuantity(typeof(UnitOfLength))]
public partial class Length { }

[ScalarQuantity(typeof(UnitOfArea), DefaultUnit = "SquareMetre", DefaultSymbol = "m²")]
public partial class Area { }

[FixedUnitInstance("Metre", "[*]s")]
[ScaledUnitInstance("Foot", "Feet", "Metre", 0.3048)]
[Unit(typeof(Length))]
public partial class UnitOfLength { }

[DerivedUnitInstance("SquareMetre", "[*]", new[] { "Metre" })]
[DerivableUnit("{0} * {0}", typeof(UnitOfLength))]
[Unit(typeof(Area))]
public partial class UnitOfArea { }
```

The above declarations would make the following code valid:

```csharp
Length length = 41.9 * Length.OneFoot;
Area area = length * length;

Console.WriteLine(area); // "163.10150605439995 [m²]"
```

### XML Documentation Injection

XML documentation for generated members can easily be injected using a simple syntax. The following could apply to `UnitOfArea.SquareMetre`:

```
# UnitInstance_SquareMetre
<summary>The SI unit, representing { <see cref="UnitOfLength.Metre"/>² }.</summary>
/#
```
