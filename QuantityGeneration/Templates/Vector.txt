namespace ErikWe.SharpMeasures.Quantities;

using ErikWe.SharpMeasures.Units;

using System;
#Vector3#
using System.Numerics;
#/Vector3#

#Document:Header(#Quantity#, #Dimensionality#, #Component#, #Unit#, #SingularBases#, #PluralUnits#)#
public readonly partial record struct #Quantity# :
    IVector#Dimensionality#Quantity,
    IScalableVector#Dimensionality#Quantity<#Quantity#>,
    INormalizableVector#Dimensionality#Quantity<#Quantity#>#CommaIfInterfaceOrTransformable#
#Vector3#
    ITransformableVector#Dimensionality#Quantity<#Quantity#>#CommaIfInterface#
#/Vector3#
#Interfaces#
{
    #Document:Zero(#Quantity#, #Dimensionality#)#
    public static #Quantity# Zero { get; } = new(#ComponentListZero#);

#ComponentListProperties#

    #Document:Components(#Quantity#, #Dimensionality#, #Unit#, #PluralUnits#)#
    public Vector#Dimensionality# Components => new(#ComponentListComponents#);

#ScalarQuantityComponent#
    #Document:ConstructorComponentTuple(#Quantity#, #Dimensionality#)#
    public #Quantity#((#ComponentListScalarQuantity#) components) : #newline#this(#ComponentListTupleAccess#) { }
    #Document:ConstructorComponents(#Quantity#, #Dimensionality#)#
    public #Quantity#(#ComponentListScalarQuantity#) : #newline#this(#ComponentListLowerCaseMagnitudes#) { }
#/ScalarQuantityComponent#
    #Document:ConstructorScalarTupleUnit(#Quantity#, #Dimensionality#, #Unit#, #UnitVariable#)#
    public #Quantity#((#ComponentListScalar#) components, #Unit# #UnitVariable#) : #newline#this(#ComponentListTupleAccess#, #UnitVariable#) { }
    #Document:ConstructorScalarsUnit(#Quantity#, #Dimensionality#, #Unit#, #UnitVariable#)#
    public #Quantity#(#ComponentListScalar#, #Unit# #UnitVariable#) : #newline#this(#ComponentListLowerCaseMagnitudes#, #UnitVariable#) { }
    #Document:ConstructorVectorUnit(#Quantity#, #Dimensionality#, #Unit#, #UnitVariable#)#
    public #Quantity#(Vector#Dimensionality# components, #Unit# #UnitVariable#) : #newline#this(#ComponentListVectorAccess#, #UnitVariable#) { }
    #Document:ConstructorDoubleTupleUnit(#Quantity#, #Dimensionality#, #Unit#, #UnitVariable#)#
    public #Quantity#((#ComponentListDouble#) components, #Unit# #UnitVariable#) : #newline#this(#ComponentListTupleAccess#, #UnitVariable#) { }
    #Document:ConstructorDoublesUnit(#Quantity#, #Dimensionality#, #Unit#, #UnitVariable#)#
    public #Quantity#(#ComponentListDouble#, #Unit# #UnitVariable#) : #newline#this(#ComponentListMagnitudeFromUnit#) { }

    #Document:ConstructorScalarTuple(#Quantity#, #Dimensionality#, #Unit#, #UnitVariable#)#
    public #Quantity#((#ComponentListScalar#) components) : #newline#this(#ComponentListTupleAccess#) { }
    #Document:ConstructorScalars(#Quantity#, #Dimensionality#, #Unit#, #UnitVariable#)#
    public #Quantity#(#ComponentListScalar#) : #newline#this(#ComponentListLowerCaseMagnitudes#) { }
    #Document:ConstructorVector(#Quantity#, #Dimensionality#, #Unit#, #UnitVariable#)#
    public #Quantity#(Vector#Dimensionality# components) : #newline#this(#ComponentListVectorAccess#) { }
    #Document:ConstructorDoubleTuple(#Quantity#, #Dimensionality#, #Unit#, #UnitVariable#)#
    public #Quantity#((#ComponentListDouble#) components) : #newline#this(#ComponentListTupleAccess#) { }
    #Document:ConstructorDoubles(#Quantity#, #Dimensionality#, #Unit#, #UnitVariable#)#
    public #Quantity#(#ComponentListDouble#)
    {
#ComponentListAssignment#
    }

#Convertible#

#Units#

#ScalarQuantityComponent#
    #Document:ScalarMagnitudeExplicit#
    Scalar IVector#Dimensionality#Quantity.Magnitude() => Maths.Vectors.Dot(this, this).SquareRoot();
    #Document:ScalarQuantityMagnitude(#Quantity#, #Dimensionality#, #Component#)#
    public #Component# Magnitude() => new(Maths.Vectors.Dot(this, this).SquareRoot());
#/ScalarQuantityComponent#
#NonScalarQuantityComponent#
    #Document:ScalarMagnitude(#Quantity#, #Dimensionality#, #Unit#)#
    public Scalar Magnitude() => Maths.Vectors.Dot(this, this).SquareRoot();
#/NonScalarQuantityComponent#
#SquaredScalarQuantityComponent#
    #Document:ScalarSquaredMagnitudeExplicit#
    Scalar IVector#Dimensionality#Quantity.SquaredMagnitude() => Maths.Vectors.Dot(this, this);
    #Document:ScalarQuantitySquaredMagnitude(#Quantity#, #Dimensionality#, #SquaredComponent#)#
    public #SquaredComponent# SquaredMagnitude() => new(Maths.Vectors.Dot(this, this));
#/SquaredScalarQuantityComponent#
#NonSquaredScalarQuantityComponent#
    #Document:ScalarSquaredMagnitude(#Quantity#, #Dimensionality#, #Unit#)#
    public Scalar SquaredMagnitude() => Maths.Vectors.Dot(this, this);
#/NonSquaredScalarQuantityComponent#

#ScalarQuantityComponent#
    #Document:Normalize(#Quantity#, #Dimensionality#)#
    public #Quantity# Normalize() => this / Magnitude().Magnitude;
#/ScalarQuantityComponent#
#NonScalarQuantityComponent#
    #Document:Normalize(#Quantity#, #Dimensionality#)#
    public #Quantity# Normalize() => this / Magnitude();
#/NonScalarQuantityComponent#
#Vector3#
    #Document:Transform(#Quantity#, #Dimensionality#)#
    public #Quantity# Transform(Matrix4x4 transform) => new(Maths.Vectors.Transform(this, transform));
#/Vector3#
    
#ScalarQuantityComponent#
    #Document:DotVector(#Quantity#, #Dimensionality#, #Component#)#
    public #Component# Dot(Vector#Dimensionality# factor) => new(Maths.Vectors.Dot(this, factor));
#/ScalarQuantityComponent#
    #Document:DotUnhandled(#Quantity#, #Dimensionality#)#
    public Unhandled Dot(Unhandled#Dimensionality# factor) => new(Maths.Vectors.Dot(this, factor));
    #Document:DotGeneric(#Quantity#, #Dimensionality#)#
    public TProductScalarQuantity Dot<TProductScalarQuantity, TFactorVector#Dimensionality#Quantity>(TFactorVector#Dimensionality#Quantity factor, Func<Scalar, TProductScalarQuantity> factory)
        where TProductScalarQuantity : IScalarQuantity
        where TFactorVector#Dimensionality#Quantity : IVector#Dimensionality#Quantity
    {
        if (factory == null)
        {
            throw new ArgumentNullException(nameof(factory));
        }
        else
        {
            return factory(Maths.Vectors.Dot(this, factor));
        }
    }

#Vector3#
    #Document:CrossVector(#Quantity#, #Dimensionality#)#
    public #Quantity# Cross(Vector#Dimensionality# factor) => new(Maths.Vectors.Cross(this, factor));
    #Document:CrossUnhandled(#Quantity#, #Dimensionality#)#
    public Unhandled#Dimensionality# Cross(Unhandled#Dimensionality# factor) => new(Maths.Vectors.Cross(this, factor));
    #Document:CrossGeneric(#Quantity#, #Dimensionality#)#
    public TProductVector#Dimensionality#Quantity Cross<TProductVector#Dimensionality#Quantity, TFactorVector#Dimensionality#Quantity>(TFactorVector#Dimensionality#Quantity factor, Func<Vector#Dimensionality#, TProductVector3Quantity> factory)
        where TProductVector#Dimensionality#Quantity : IVector#Dimensionality#Quantity
        where TFactorVector#Dimensionality#Quantity : IVector#Dimensionality#Quantity
    {
        if (factory == null)
        {
            throw new ArgumentNullException(nameof(factory));
        }
        else
        {
            return factory(Maths.Vectors.Cross(this, factor));
        }
    }
#/Vector3#

    #Document:ToString(#Quantity#, #Dimensionality#, #Unit#, #DefaultUnit#, #DefaultSymbol#)#
    public override string ToString() => $"{#DefaultUnits#} [#DefaultSymbol#]";

    #Document:InUnitInstance(#Quantity#, #Dimensionality#, #Unit#, #UnitVariable#)#
    public Vector#Dimensionality# InUnit(#Unit# #UnitVariable#) => InUnit(this, #UnitVariable#);
    #Document:InUnitStatic(#Quantity#, #quantity#, #Dimensionality#, #Unit#, #UnitVariable#)#
    private static Vector#Dimensionality# InUnit(#Quantity# #quantity#, #Unit# #UnitVariable#) #newline#=> #QuantityToUnit#;
    
    #Document:PlusMethod(#Quantity#, #Dimensionality#)#
    public #Quantity# Plus() => this;
    #Document:NegateMethod(#Quantity#, #Dimensionality#)#
    public #Quantity# Negate() => new(#ComponentListNegate#);
    #Document:PlusOperator(#Quantity#, #Dimensionality#)#
    public static #Quantity# operator +(#Quantity# a) => a;
    #Document:NegateOperator(#Quantity#, #Dimensionality#)#
    public static #Quantity# operator -(#Quantity# a) => new(#ComponentListNegateA#);

    #Document:MultiplyUnhandledMethod(#Quantity#, #Dimensionality#)#
    public Unhandled#Dimensionality# Multiply(Unhandled factor) => new(#ComponentListMultiplication#);
    #Document:DivideUnhandledMethod(#Quantity#, #Dimensionality#)#
    public Unhandled#Dimensionality# Divide(Unhandled divisor) => new(#ComponentListDivision#);
    #Document:MultiplyUnhandledOperatorLHS(#Quantity#, #Dimensionality#)#
    public static Unhandled#Dimensionality# operator *(#Quantity# a, Unhandled b) => new(#ComponentListVectorATimesScalarB#);
    #Document:MultiplyUnhandledOperatorRHS(#Quantity#, #Dimensionality#)#
    public static Unhandled#Dimensionality# operator *(Unhandled a, #Quantity# b) => new(#ComponentListScalarATimesVectorB#);
    #Document:DivideUnhandledOperator(#Quantity#, #Dimensionality#)#
    public static Unhandled#Dimensionality# operator /(#Quantity# a, Unhandled b) => new(#ComponentListVectorADividedByScalarB#);

    #Document:RemainderDoubleMethod(#Quantity#, #Dimensionality#)#
    public #Quantity# Remainder(double divisor) => new(#ComponentListRemainderDouble#);
    #Document:MultiplyDoubleMethod(#Quantity#, #Dimensionality#)#
    public #Quantity# Multiply(double factor) => new(#ComponentListMultiplicationDouble#);
    #Document:DivideDoubleMethod(#Quantity#, #Dimensionality#)#
    public #Quantity# Divide(double divisor) => new(#ComponentListDivisionDouble#);
    #Document:RemainderDoubleOperator(#Quantity#, #Dimensionality#)#
    public static #Quantity# operator %(#Quantity# a, double b) => new(#ComponentListVectorARemainderDoubleB#);
    #Document:MultiplyDoubleOperatorLHS(#Quantity#, #Dimensionality#)#
    public static #Quantity# operator *(#Quantity# a, double b) => new(#ComponentListVectorATimesDoubleB#);
    #Document:MultiplyDoubleOperatorRHS(#Quantity#, #Dimensionality#)#
    public static #Quantity# operator *(double a, #Quantity# b) => new(#ComponentListDoubleATimesVectorB#);
    #Document:DivideDoubleOperator(#Quantity#, #Dimensionality#)#
    public static #Quantity# operator /(#Quantity# a, double b) => new(#ComponentListVectorADividedByDoubleB#);

    #Document:RemainderScalarMethod(#Quantity#, #Dimensionality#)#
    public #Quantity# Remainder(Scalar divisor) => new(#ComponentListRemainder#);
    #Document:MultiplyScalarMethod(#Quantity#, #Dimensionality#)#
    public #Quantity# Multiply(Scalar factor) => new(#ComponentListMultiplication#);
    #Document:DivideScalarMethod(#Quantity#, #Dimensionality#)#
    public #Quantity# Divide(Scalar divisor) => new(#ComponentListDivision#);
    #Document:RemainderScalarOperator(#Quantity#, #Dimensionality#)#
    public static #Quantity# operator %(#Quantity# a, Scalar b) => new(#ComponentListVectorARemainderScalarB#);
    #Document:MultiplyScalarOperatorLHS(#Quantity#, #Dimensionality#)#
    public static #Quantity# operator *(#Quantity# a, Scalar b) => new(#ComponentListVectorATimesScalarB#);
    #Document:MultiplyScalarOperatorRHS(#Quantity#, #Dimensionality#)#
    public static #Quantity# operator *(Scalar a, #Quantity# b) => new(#ComponentListScalarATimesVectorB#);
    #Document:DivideScalarOperator(#Quantity#, #Dimensionality#)#
    public static #Quantity# operator /(#Quantity# a, Scalar b) => new(#ComponentListVectorADividedByScalarB#);

    #Document:MultiplyGeneric(#Quantity#, #Dimensionality#)#
    public TProductVector#Dimensionality#Quantity Multiply<TProductVector#Dimensionality#Quantity, TFactorScalarQuantity>(TFactorScalarQuantity factor, Func<#ComponentListUnnamedDoubles#, TProductVector#Dimensionality#Quantity> factory)
        where TProductVector#Dimensionality#Quantity : IVector#Dimensionality#Quantity
        where TFactorScalarQuantity : IScalarQuantity
    {
        if (factory == null)
        {
            throw new ArgumentNullException(nameof(factory));
        }
        else
        {
            return factory(#ComponentListMultiplication#);
        }
    }

    #Document:DivideGeneric(#Quantity#, #Dimensionality#)#
    public TQuotientVector#Dimensionality#Quantity Divide<TQuotientVector#Dimensionality#Quantity, TDivisorScalarQuantity>(TDivisorScalarQuantity divisor, Func<#ComponentListUnnamedDoubles#, TQuotientVector#Dimensionality#Quantity> factory)
        where TQuotientVector#Dimensionality#Quantity : IVector#Dimensionality#Quantity
        where TDivisorScalarQuantity : IScalarQuantity
    {
        if (factory == null)
        {
            throw new ArgumentNullException(nameof(factory));
        }
        else
        {
            return factory(#ComponentListDivision#);
        }
    }

    #Document:MultiplyIScalarLHS(#Quantity#, #Dimensionality#)#
    public static Unhandled#Dimensionality# operator *(#Quantity# a, IScalarQuantity b) #newline#=> a.Multiply<Unhandled#Dimensionality#, IScalarQuantity>(b, (#ComponentListLowerCaseName#) => new Unhandled#Dimensionality#(#ComponentListLowerCaseName#));
    #Document:MultiplyIScalarRHS(#Quantity#, #Dimensionality#)#
    public static Unhandled#Dimensionality# operator *(IScalarQuantity a, #Quantity# b) #newline#=> b.Multiply<Unhandled#Dimensionality#, IScalarQuantity>(a, (#ComponentListLowerCaseName#) => new Unhandled#Dimensionality#(#ComponentListLowerCaseName#));
    #Document:DivideIScalar(#Quantity#, #Dimensionality#)#
    public static Unhandled#Dimensionality# operator /(#Quantity# a, IScalarQuantity b) #newline#=> a.Divide<Unhandled#Dimensionality#, IScalarQuantity>(b, (#ComponentListLowerCaseName#) => new Unhandled#Dimensionality#(#ComponentListLowerCaseName#));

    #Document:ToValueTupleMethod(#Quantity#, #Dimensionality#)#
    public (#ComponentListDouble#) ToValueTuple() => (#ComponentListComponents#);
    #Document:ToValueTupleOperator(#Quantity#, #Dimensionality#)#
    public static explicit operator (#ComponentListDouble#)(#Quantity# a) => (#ComponentListAAccess#);

    #Document:ToVectorMethod(#Quantity#, #Dimensionality#)#
    public Vector#Dimensionality# ToVector#Dimensionality#() => new(#ComponentListComponents#);
    #Document:ToVectorOperator(#Quantity#, #Dimensionality#)#
    public static explicit operator Vector#Dimensionality#(#Quantity# a) => new(#ComponentListAAccess#);

    #Document:FromValueTupleMethod(#Quantity#, #Dimensionality#)#
    public static #Quantity# FromValueTuple((#ComponentListDouble#) components) => new(components);
    #Document:FromValueTupleOperator(#Quantity#, #Dimensionality#)#
    public static explicit operator #Quantity#((#ComponentListDouble#) components) => new(components);

    #Document:FromVectorMethod(#Quantity#, #Dimensionality#)#
    public static #Quantity# FromVector#Dimensionality#(Vector#Dimensionality# a) => new(a);
    #Document:FromVectorOperator(#Quantity#, #Dimensionality#)#
    public static explicit operator #Quantity#(Vector#Dimensionality# a) => new(a);
}