namespace ErikWe.SharpMeasures.Quantities;

using ErikWe.SharpMeasures.Units;

using System;

#Document:Header(#Quantity#, #Unit#, #SingularBases#, #PluralUnits#)#
public readonly partial record struct #Quantity# :
    IComparable<#Quantity#>,
    IScalarQuantity,
    IScalableScalarQuantity<#Quantity#>#CommaIfInterface#
#Interfaces#
{
    #Document:Zero(#Quantity#)#
    public static #Quantity# Zero { get; } = new(0);

#Bases#

#From#
    
    #Document:Magnitude(#Quantity#, #Unit#, #PluralUnits#)#
    public double Magnitude { get; init; }

    #Document:ConstructorScalarUnit(#Quantity#, #Unit#, #UnitVariable#, #SingularUnits#)#
    public #Quantity#(Scalar magnitude, #Unit# #UnitVariable#) : this(magnitude.Magnitude, #UnitVariable#) { }
    #Document:ConstructorDoubleUnit(#Quantity#, #Unit#, #UnitVariable#, #SingularUnits#)#
    public #Quantity#(double magnitude, #Unit# #UnitVariable#) : #newline#this(#MagnitudeFromUnitDouble#) { }
    #Document:ConstructorScalar(#Quantity#, #Unit#)#
    public #Quantity#(Scalar magnitude) : this(magnitude.Magnitude) { }
    #Document:ConstructorDouble(#Quantity#, #Unit#)#
    public #Quantity#(double magnitude)
    {
        Magnitude = magnitude;
    }

#Convertible#

#Units#

    #Document:IsNaN(#Quantity#)#
    public bool IsNaN => double.IsNaN(Magnitude);
    #Document:IsZero(#Quantity#)#
    public bool IsZero => Magnitude == 0;
    #Document:IsPositive(#Quantity#)#
    public bool IsPositive => Magnitude > 0;
    #Document:IsNegative(#Quantity#)#
    public bool IsNegative => double.IsNegative(Magnitude);
    #Document:IsFinite(#Quantity#)#
    public bool IsFinite => double.IsFinite(Magnitude);
    #Document:IsInfinite(#Quantity#)#
    public bool IsInfinite => IsPositiveInfinity || IsNegativeInfinity;
    #Document:IsPositiveInfinity(#Quantity#)#
    public bool IsPositiveInfinity => double.IsPositiveInfinity(Magnitude);
    #Document:IsNegativeInfinity(#Quantity#)#
    public bool IsNegativeInfinity => double.IsNegativeInfinity(Magnitude);

    #Document:Absolute(#Quantity#)#
    public #Quantity# Absolute() => new(Math.Abs(Magnitude));
    #Document:Floor(#Quantity#)#
    public #Quantity# Floor() => new(Math.Floor(Magnitude));
    #Document:Ceiling(#Quantity#)#
    public #Quantity# Ceiling() => new(Math.Ceiling(Magnitude));
    #Document:Round(#Quantity#)#
    public #Quantity# Round() => new(Math.Round(Magnitude));

#Powers#

    #Document:CompareTo#
    public int CompareTo(#Quantity# other) => Magnitude.CompareTo(other.Magnitude);
    #Document:ToString(#Quantity#, #Unit#, #DefaultUnit#, #DefaultSymbol#)#
    public override string ToString() => $"{#DefaultUnits#} [#DefaultSymbol#]";

    #Document:InUnitInstance(#Quantity#, #Unit#, #UnitVariable#)#
    public Scalar InUnit(#Unit# #UnitVariable#) => InUnit(this, #UnitVariable#);
    #Document:InUnitStatic(#Quantity#, #quantity#, #Unit#, #UnitVariable#)#
    private static Scalar InUnit(#Quantity# #quantity#, #Unit# #UnitVariable#) #newline#=> new(#QuantityToUnit#);

    #Document:PlusMethod(#Quantity#)#
    public #Quantity# Plus() => this;
    #Document:NegateMethod(#Quantity#)#
    public #Quantity# Negate() => new(-Magnitude);
    #Document:PlusOperator(#Quantity#)#
    public static #Quantity# operator +(#Quantity# x) => x.Plus();
    #Document:NegateOperator(#Quantity#)#
    public static #Quantity# operator -(#Quantity# x) => x.Negate();

    #Document:MultiplyUnhandledMethod(#Quantity#)#
    public Unhandled Multiply(Unhandled factor) => new(Magnitude * factor.Magnitude);
    #Document:DivideUnhandledMethod(#Quantity#)#
    public Unhandled Divide(Unhandled divisor) => new(Magnitude / divisor.Magnitude);
    #Document:MultiplyUnhandledOperatorLHS(#Quantity#)#
    public static Unhandled operator *(#Quantity# x, Unhandled y) => x.Multiply(y);
    #Document:MultiplyUnhandledOperatorRHS(#Quantity#)#
    public static Unhandled operator *(Unhandled x, #Quantity# y) => y.Multiply(x);
    #Document:DivideUnhandledOperator(#Quantity#)#
    public static Unhandled operator /(#Quantity# x, Unhandled y) => x.Divide(y);

    #Document:RemainderDoubleMethod(#Quantity#)#
    public #Quantity# Remainder(double divisor) => new(Magnitude % divisor);
    #Document:MultiplyDoubleMethod(#Quantity#)#
    public #Quantity# Multiply(double factor) => new(Magnitude * factor);
    #Document:DivideDoubleMethod(#Quantity#)#
    public #Quantity# Divide(double divisor) => new(Magnitude / divisor);
    #Document:RemainderDoubleOperator(#Quantity#)#
    public static #Quantity# operator %(#Quantity# x, double y) => x.Remainder(y);
    #Document:MultiplyDoubleOperatorLHS(#Quantity#)#
    public static #Quantity# operator *(#Quantity# x, double y) => x.Multiply(y);
    #Document:MultiplyDoubleOperatorRHS(#Quantity#)#
    public static #Quantity# operator *(double x, #Quantity# y) => y.Multiply(x);
    #Document:DivideDoubleOperatorLHS(#Quantity#)#
    public static #Quantity# operator /(#Quantity# x, double y) => x.Divide(y);
#InversionOperatorDouble#

    #Document:RemainderScalarMethod(#Quantity#)#
    public #Quantity# Remainder(Scalar divisor) => Remainder(divisor.Magnitude);
    #Document:MultiplyScalarMethod(#Quantity#)#
    public #Quantity# Multiply(Scalar factor) => Multiply(factor.Magnitude);
    #Document:DivideScalarMethod(#Quantity#)#
    public #Quantity# Divide(Scalar divisor) => Divide(divisor.Magnitude);
    #Document:RemainderScalarOperator(#Quantity#)#
    public static #Quantity# operator %(#Quantity# x, Scalar y) => x.Remainder(y);
    #Document:MultiplyScalarOperatorLHS(#Quantity#)#
    public static #Quantity# operator *(#Quantity# x, Scalar y) => x.Multiply(y);
    #Document:MultiplyScalarOperatorRHS(#Quantity#)#
    public static #Quantity# operator *(Scalar x, #Quantity# y) => y.Multiply(x);
    #Document:DivideScalarOperatorLHS(#Quantity#)#
    public static #Quantity# operator /(#Quantity# x, Scalar y) => x.Divide(y);
#InversionOperatorScalar#

    #Document:MultiplyGeneric(#Quantity#)#
    public TProductScalarQuantity Multiply<TProductScalarQuantity, TFactorScalarQuantity>(TFactorScalarQuantity factor, Func<double, TProductScalarQuantity> factory)
        where TProductScalarQuantity : IScalarQuantity
        where TFactorScalarQuantity : IScalarQuantity
    {
        if (factory == null)
        {
            throw new ArgumentNullException(nameof(factory));
        }
        else
        {
            return factory(Magnitude * factor.Magnitude);
        }
    }

    #Document:DivideGeneric(#Quantity#)#
    public TQuotientScalarQuantity Divide<TQuotientScalarQuantity, TDivisorScalarQuantity>(TDivisorScalarQuantity divisor, Func<double, TQuotientScalarQuantity> factory)
        where TQuotientScalarQuantity : IScalarQuantity
        where TDivisorScalarQuantity : IScalarQuantity
    {
        if (factory == null)
        {
            throw new ArgumentNullException(nameof(factory));
        }
        else
        {
            return factory(Magnitude / divisor.Magnitude);
        }
    }

    #Document:MultiplyIScalar(#Quantity#)#
    public static Unhandled operator *(#Quantity# x, IScalarQuantity y) => x.Multiply<Unhandled, IScalarQuantity>(y, (m) => new Unhandled(m));
    #Document:DivideIScalar(#Quantity#)#
    public static Unhandled operator /(#Quantity# x, IScalarQuantity y) => x.Divide<Unhandled, IScalarQuantity>(y, (m) => new Unhandled(m));

#ToVector#

    #Document:LessThan(#Quantity#)#
    public static bool operator <(#Quantity# x, #Quantity# y) => x.Magnitude < y.Magnitude;
    #Document:GreaterThan(#Quantity#)#
    public static bool operator >(#Quantity# x, #Quantity# y) => x.Magnitude > y.Magnitude;
    #Document:LessThanOrEqual(#Quantity#)#
    public static bool operator <=(#Quantity# x, #Quantity# y) => x.Magnitude <= y.Magnitude;
    #Document:GreaterThanOrEqual(#Quantity#)#
    public static bool operator >=(#Quantity# x, #Quantity# y) => x.Magnitude >= y.Magnitude;

    #Document:ToDoubleMethod(#Quantity#)#
    public double ToDouble() => Magnitude;
    #Document:ToDoubleOperator(#Quantity#)#
    public static explicit operator double(#Quantity# x) => x.ToDouble();

    #Document:ToScalarMethod(#Quantity#)#
    public Scalar ToScalar() => new(Magnitude);
    #Document:ToScalarOperator(#Quantity#)#
    public static explicit operator Scalar(#Quantity# x) => x.ToScalar();

    #Document:FromDoubleMethod(#Quantity#)#
    public static #Quantity# FromDouble(double x) => new(x);
    #Document:FromDoubleOperator(#Quantity#)#
    public static explicit operator #Quantity#(double x) => FromDouble(x);

    #Document:FromScalarMethod(#Quantity#)#
    public static #Quantity# FromScalar(Scalar x) => new(x);
    #Document:FromScalarOperator(#Quantity#)#
    public static explicit operator #Quantity#(Scalar x) => FromScalar(x);
}