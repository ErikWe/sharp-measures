namespace ErikWe.SharpMeasures.Quantities;

using ErikWe.SharpMeasures.Units;

#Vector3#
using System.Numerics;
#/Vector3#

public readonly partial record struct #Quantity#(#ComponentsDefinition#) :
    IVector#Dimensionality#<#Quantity#>#CommaIfInterface#
#Interfaces#
{
    public static #Quantity# Zero { get; } = new(#ZeroComponents#);
    public static #Quantity# Ones { get; } = new(Vector#Dimensionality#.Ones);

    public Vector#Dimensionality# AsVector#Dimensionality#() => new(#Components#);
#SharedUnits#

    public #Quantity#((#DoubleDefinition#) components) : this(#TupleAccess#) { }
    public #Quantity#((#DoubleDefinition#) components, #Unit# #UnitVariable#) :
        this(#TupleAccess#, #UnitVariable#) { }
    public #Quantity#(#DoubleDefinition#, #Unit# #UnitVariable#) :
        this(#ComponentsFromUnit#) { }

#Units#

#ComponentMagnitude#
    Scalar IVector#Dimensionality#.Magnitude() => Maths.Vectors.Dot(this, this).SquareRoot();
    public #Component# Magnitude() => new(Maths.Vectors.Dot(this, this).SquareRoot());
#/ComponentMagnitude#
#DoubleMagnitude#
    public Scalar Magnitude() => Maths.Vectors.Dot(this, this).SquareRoot();
#/DoubleMagnitude#
#QuantitySquaredMagnitude#
    Scalar IVector#Dimensionality#.SquaredMagnitude() => Maths.Vectors.Dot(this, this);
    public #SquaredComponent# SquaredMagnitude() => new(Maths.Vectors.Dot(this, this));
#/QuantitySquaredMagnitude#
#DoubleSquaredMagnitude#
    public Scalar SquaredMagnitude() => Maths.Vectors.Dot(this, this);
#/DoubleSquaredMagnitude#

#ComponentNormalization#
    public #Quantity# Normalize() => this / Magnitude().Magnitude;
#/ComponentNormalization#
#DoubleNormalization#
    public #Quantity# Normalize() => this / Magnitude();
#/DoubleNormalization#
#Vector3#
    public #Quantity# Transform(Matrix4x4 transform) => new(Maths.Vectors.Transform(this, transform));
#/Vector3#

    public Unhandled Dot(Unhandled#Dimensionality# factor) => new(Maths.Vectors.Dot(this, factor));
    public Unhandled Dot<TQuantity>(TQuantity factor) where TQuantity : IVector#Dimensionality# => new(Maths.Vectors.Dot(this, factor));
#Vector3#
    public Unhandled#Dimensionality# Cross(Unhandled#Dimensionality# factor) => new(Maths.Vectors.Cross(this, factor));
    public Unhandled#Dimensionality# Cross<TQuantity>(TQuantity factor) where TQuantity : IVector#Dimensionality# => new(Maths.Vectors.Cross(this, factor));
#/Vector3#

    public override string ToString() => $"(#ComponentsFormatting#) [#Abbreviation#]";

    public Vector#Dimensionality# InUnit(#Unit# #UnitVariable#) => InUnit(AsVector#Dimensionality#(), #UnitVariable#);
    private static Vector#Dimensionality# InUnit(Vector#Dimensionality# vector, #Unit# #UnitVariable#) => #ComponentsToUnit#;

    public #Quantity# Plus() => this;
    public #Quantity# Negate() => new(#NegateComponents#);
    public static #Quantity# operator +(#Quantity# a) => a;
    public static #Quantity# operator -(#Quantity# a) => new(#NegateA#);

#Additive#

    public Unhandled#Dimensionality# Multiply(Unhandled factor) => new(#ComponentsTimesFactor#);
    public Unhandled#Dimensionality# Divide(Unhandled divisor) => new(#ComponentsDividedByDivisor#);
    public static Unhandled#Dimensionality# operator *(#Quantity# a, Unhandled b) => new(#VectorATimesScalarB#);
    public static Unhandled#Dimensionality# operator *(Unhandled a, #Quantity# b) => new(#ScalarATimesVectorB#);
    public static Unhandled#Dimensionality# operator /(#Quantity# a, Unhandled b) => new(#ADividedByB#);

    public #Quantity# Remainder(double divisor) => new(#ComponentsRemainderDivisor#);
    public #Quantity# Multiply(double factor) => new(#ComponentsTimesFactor#);
    public #Quantity# Divide(double divisor) => new(#ComponentsDividedByDivisor#);
    public static #Quantity# operator %(#Quantity# a, double b) => new(#ARemainderB#);
    public static #Quantity# operator *(#Quantity# a, double b) => new(#VectorATimesScalarB#);
    public static #Quantity# operator *(double a, #Quantity# b) => new(#ScalarATimesVectorB#);
    public static #Quantity# operator /(#Quantity# a, double b) => new(#ADividedByB#);

    public #Quantity# Remainder(Scalar divisor) => new(#ComponentsRemainderDivisor#);
    public #Quantity# Multiply(Scalar factor) => new(#ComponentsTimesFactor#);
    public #Quantity# Divide(Scalar divisor) => new(#ComponentsDividedByDivisor#);
    public static #Quantity# operator %(#Quantity# a, Scalar b) => new(#ARemainderB#);
    public static #Quantity# operator *(#Quantity# a, Scalar b) => new(#VectorATimesScalarB#);
    public static #Quantity# operator *(Scalar a, #Quantity# b) => new(#ScalarATimesVectorB#);
    public static #Quantity# operator /(#Quantity# a, Scalar b) => new(#ADividedByB#);

    public Unhandled#Dimensionality# Multiply<TScalarQuantity>(TScalarQuantity factor) where TScalarQuantity : IScalarQuantity => new(#ComponentsTimesFactorMagnitude#);
    public Unhandled#Dimensionality# Divide<TScalarQuantity>(TScalarQuantity divisor) where TScalarQuantity : IScalarQuantity => new(#ComponentsDividedByDivisorMagnitude#);
    public static Unhandled#Dimensionality# operator *(#Quantity# a, IScalarQuantity b) => new(#VectorATimesScalarBMagnitude#);
    public static Unhandled#Dimensionality# operator *(IScalarQuantity a, #Quantity# b) => new(#ScalarAMagnitudeTimesVectorB#);
    public static Unhandled#Dimensionality# operator /(#Quantity# a, IScalarQuantity b) => new(#ADividedByBMagnitude#);

    public (#DoubleDefinition#) ToValueTuple() => (#Components#);
    public static implicit operator (#DoubleDefinition#)(#Quantity# a) => (#aAccess#);

    public Vector#Dimensionality# ToVector#Dimensionality#() => new(#Components#);
    public static explicit operator Vector#Dimensionality#(#Quantity# a) => new(#aAccess#);

    public static #Quantity# FromValueTuple((#DoubleDefinition#) components) => new(components);
    public static explicit operator #Quantity#((#DoubleDefinition#) components) => new(components);

    public static #Quantity# FromVector#Dimensionality#(Vector#Dimensionality# a) => new(a);
    public static explicit operator #Quantity#(Vector#Dimensionality# a) => new(a);
}