namespace SharpMeasures.Generators.Units.Pipelines.Common;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

using SharpMeasures.Generators.SourceBuilding;

using System.Collections.Generic;
using System.Text;

internal static class Execution
{
    public static void Execute(SourceProductionContext context, DataModel data)
    {
        string source = Composer.Compose(context, data);

        context.AddSource($"{data.Unit.Name}_Common.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private class Composer
    {
        public static string Compose(SourceProductionContext context, DataModel data)
        {
            Composer composer = new(context, data);
            composer.Compose();
            return composer.Retrieve();
        }

        private SourceProductionContext Context { get; }
        private StringBuilder Builder { get; } = new();

        private DataModel Data { get; }

        private UsingsCollector UsingsCollector { get; }
        private InterfaceCollector InterfaceCollector { get; }

        private Composer(SourceProductionContext context, DataModel data)
        {
            Context = context;
            Data = data;

            UsingsCollector = UsingsCollector.Delayed(Builder, Data.Unit.Namespace);
            InterfaceCollector = InterfaceCollector.Delayed(Builder);

            UsingsCollector.AddUsings("SharpMeasures", Data.Quantity.Namespace);

            if (Data.Biased is false)
            {
                UsingsCollector.AddUsings("System");
                InterfaceCollector.AddInterface($"IComparable<{Data.Unit.Name}>");
            }
        }

        private void Compose()
        {
            StaticBuilding.AppendAutoGeneratedHeader(Builder);
            StaticBuilding.AppendNullableDirective(Builder);

            NamespaceBuilding.AppendNamespace(Builder, Data.Unit.Namespace);

            List<string> usings = new(new[] { "SharpMeasures" });

            UsingsCollector.MarkInsertionPoint();

            AppendDocumentation(new Indentation(0), UnitDocumentationTags.UnitHeader);
            Builder.Append(Data.Unit.ComposeDeclaration());

            InterfaceCollector.MarkInsertionPoint();

            BlockBuilding.AppendBlock(Builder, ComposeTypeBlock, originalIndentationLevel: 0);

            InterfaceCollector.InsertInterfaces();
            UsingsCollector.InsertUsings();
        }

        private string Retrieve()
        {
            return Builder.ToString();
        }

        private void ComposeTypeBlock(Indentation indentation)
        {
            if (Data.Biased)
            {
                ComposeBiasedTypeBlock(indentation);
            }
            else
            {
                ComposeUnbiasedTypeBlock(indentation);
            }
        }

        private void ComposeUnbiasedTypeBlock(Indentation indentation)
        {
            AppendDocumentation(indentation, UnitDocumentationTags.Quantity);
            Builder.AppendLine($"{indentation}public {Data.Quantity.Name} {Data.Quantity.Name} {{ get; }}");

            AppendDocumentation(indentation, UnitDocumentationTags.Constructor);
            BlockBuilding.AppendBlock(Builder,
                header: $"private {Data.Unit.Name}({Data.Quantity.Name} {Data.Quantity.ParameterName})",
                blockContentAppender: constructorBlock,
                originalIndentationLevel: indentation.Level);

            void constructorBlock(Indentation indentation)
            {
                Builder.Append($"{indentation}{Data.Quantity.Name} = {Data.Quantity.ParameterName};");
            }

            Builder.AppendLine();

            AppendDocumentation(indentation, UnitDocumentationTags.ScaledBy_Scalar);
            Builder.AppendLine($"{indentation}public {Data.Unit.Name} ScaledBy(Scalar scale) => ScaledBy(scale.Value);");
            AppendDocumentation(indentation, UnitDocumentationTags.ScaledBy_Double);
            Builder.AppendLine($"{indentation}public {Data.Unit.Name} ScaledBy(double scale) => new({Data.Quantity.Name} * scale);");

            Builder.AppendLine();

            AppendDocumentation(indentation, UnitDocumentationTags.WithPrefix_Metric);
            Builder.AppendLine($"{indentation}public {Data.Unit.Name} WithPrefix(MetricPrefix prefix) => ScaledBy(prefix.Factor);");
            AppendDocumentation(indentation, UnitDocumentationTags.WithPrefix_Binary);
            Builder.AppendLine($"{indentation}public {Data.Unit.Name} WithPrefix(BinaryPrefix prefix) => ScaledBy(prefix.Factor);");

            Builder.AppendLine();

            AppendDocumentation(indentation, UnitDocumentationTags.ToString);
            Builder.AppendLine($@"{indentation}public override string ToString() => $""{{typeof({Data.Unit.Name})}}: [{{{Data.Quantity.Name}}}]"";");

            Builder.AppendLine();

            AppendDocumentation(indentation, UnitDocumentationTags.Comparable.CompareTo_SameType);
            Builder.AppendLine($"{indentation}public int CompareTo({Data.Unit.Name} other) " +
                $"=> {Data.Quantity.Name}.Magnitude.Value.CompareTo(other.{Data.Quantity.Name}.Magnitude.Value);");

            Builder.AppendLine();

            AppendDocumentation(indentation, UnitDocumentationTags.Comparable.Operators.LessThan_SameType);
            Builder.AppendLine($"{indentation}public static bool operator <({Data.Unit.Name} x, {Data.Unit.Name} y) " +
                $"=> x.{Data.Quantity.Name}.Magnitude.Value < y.{Data.Quantity.Name}.Magnitude.Value;");
            AppendDocumentation(indentation, UnitDocumentationTags.Comparable.Operators.GreaterThan_SameType);
            Builder.AppendLine($"{indentation}public static bool operator >({Data.Unit.Name} x, {Data.Unit.Name} y) " +
                $"=> x.{Data.Quantity.Name}.Magnitude.Value > y.{Data.Quantity.Name}.Magnitude.Value;");
            AppendDocumentation(indentation, UnitDocumentationTags.Comparable.Operators.LessThanOrEqual_SameType);
            Builder.AppendLine($"{indentation}public static bool operator <=({Data.Unit.Name} x, {Data.Unit.Name} y) " +
                $"=> x.{Data.Quantity.Name}.Magnitude.Value <= y.{Data.Quantity.Name}.Magnitude.Value;");
            AppendDocumentation(indentation, UnitDocumentationTags.Comparable.Operators.GreaterThanOrEqual_SameType);
            Builder.AppendLine($"{indentation}public static bool operator >=({Data.Unit.Name} x, {Data.Unit.Name} y) " +
                $"=> x.{Data.Quantity.Name}.Magnitude.Value >= y.{Data.Quantity.Name}.Magnitude.Value;");
        }

        private void ComposeBiasedTypeBlock(Indentation indentation)
        {
            AppendDocumentation(indentation, UnitDocumentationTags.Quantity);
            Builder.AppendLine($"{indentation}public {Data.Quantity.Name} {Data.Quantity.Name} {{ get; }}");
            AppendDocumentation(indentation, UnitDocumentationTags.Offset);
            Builder.AppendLine($"{indentation}public Scalar Offset {{ get; }}");

            AppendDocumentation(indentation, UnitDocumentationTags.Constructor);
            BlockBuilding.AppendBlock
            (
                source: Builder,
                header: $"private {Data.Unit.Name}({Data.Quantity.Name} {Data.Quantity.ParameterName}, Scalar offset)",
                blockContentAppender: constructorBlock,
                originalIndentationLevel: indentation.Level
            );

            void constructorBlock(Indentation indentation)
            {
                Builder.AppendLine($"{indentation}{Data.Quantity.Name} = {Data.Quantity.ParameterName};");
                Builder.AppendLine($"{indentation}Offset = offset;");
            }

            Builder.AppendLine();
            AppendDocumentation(indentation, UnitDocumentationTags.ScaledBy_Scalar);
            Builder.AppendLine($"{indentation}public {Data.Unit.Name} ScaledBy(Scalar scale) => ScaledBy(scale.Value);");
            AppendDocumentation(indentation, UnitDocumentationTags.ScaledBy_Double);
            Builder.AppendLine($"{indentation}public {Data.Unit.Name} ScaledBy(double scale) => new({Data.Quantity.Name} * scale, Offset / scale);");

            Builder.AppendLine();
            AppendDocumentation(indentation, UnitDocumentationTags.OffsetBy_Scalar);
            Builder.AppendLine($"{indentation}public {Data.Unit.Name} OffsetBy(Scalar offset) => OffsetBy(offset.Value);");
            AppendDocumentation(indentation, UnitDocumentationTags.OffsetBy_Double);
            Builder.AppendLine($"{indentation}public {Data.Unit.Name} OffsetBy(double offset) => new({Data.Quantity.Name}, Offset + offset);");

            Builder.AppendLine();
            AppendDocumentation(indentation, UnitDocumentationTags.WithPrefix_Metric);
            Builder.AppendLine($"{indentation}public {Data.Unit.Name} WithPrefix(MetricPrefix prefix) => ScaledBy(prefix.Factor);");
            AppendDocumentation(indentation, UnitDocumentationTags.WithPrefix_Binary);
            Builder.AppendLine($"{indentation}public {Data.Unit.Name} WithPrefix(BinaryPrefix prefix) => ScaledBy(prefix.Factor);");

            Builder.AppendLine();
            AppendDocumentation(indentation, UnitDocumentationTags.ToString);
            Builder.AppendLine($"{indentation}public override string ToString() => \"{{typeof({Data.Unit.Name})}}: ({{{Data.Quantity.Name}}} + {{Offset}})\";");
        }

        private void AppendDocumentation(Indentation indentation, string tag)
        {
            DocumentationBuilding.AppendDocumentation(Context, Builder, Data.Documentation, indentation, tag);
        }
    }
}
