namespace SharpMeasures.Generators.Scalars.Pipelines.Common;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

using SharpMeasures.Generators.SourceBuilding;

using System.Text;

internal static class Execution
{
    public static void Execute(SourceProductionContext context, DataModel data)
    {
        string source = Composer.Compose(data);

        context.AddSource($"{data.Scalar.Name}_Common.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private class Composer
    {
        public static string Compose(DataModel data)
        {
            Composer composer = new(data);
            composer.Compose();
            return composer.Retrieve();
        }

        private StringBuilder Builder { get; } = new();

        private DataModel Data { get; }

        private Composer(DataModel data)
        {
            Data = data;
        }

        private void Compose()
        {
            StaticBuilding.AppendAutoGeneratedHeader(Builder);
            StaticBuilding.AppendNullableDirective(Builder);

            NamespaceBuilding.AppendNamespace(Builder, Data.Scalar.Namespace);

            UsingsBuilding.AppendUsings(Builder, Data.Scalar.Namespace, new string[]
            {
                "System",
                "SharpMeasures",
                Data.Unit.Namespace
            });

            AppendDocumentation(new Indentation(0), Data.Documentation.Header());
            Builder.Append(Data.Scalar.ComposeDeclaration());

            InterfaceBuilding.AppendInterfaceImplementation(Builder, new string[]
            {
                $"IComparable<{Data.Scalar.Name}>",
                "IScalarQuantity"
            });

            BlockBuilding.AppendBlock(Builder, ComposeTypeBlock, originalIndentationLevel: 0);
        }

        private string Retrieve()
        {
            return Builder.ToString();
        }

        private void ComposeTypeBlock(Indentation indentation)
        {
            if (Data.Biased is false)
            {
                AppendDocumentation(indentation, Data.Documentation.Zero());
                Builder.AppendLine($"{indentation}public static {Data.Scalar.Name} Zero {{ get; }} = new(0);");

                Builder.AppendLine();
            }

            AppendDocumentation(indentation, Data.Documentation.Magnitude());
            Builder.AppendLine($"{indentation}public Scalar Magnitude {{ get; }}");

            Builder.AppendLine();

            AppendDocumentation(indentation, Data.Documentation.ScalarConstructor());
            Builder.AppendLine($@"{indentation}public {Data.Scalar.Name}(Scalar magnitude)");
            BlockBuilding.AppendBlock(Builder, composeConstructorBlock, indentation);

            void composeConstructorBlock(Indentation indentation)
            {
                Builder.AppendLine("Magnitude = magnitude;");
            }

            Builder.AppendLine();

            AppendDocumentation(indentation, Data.Documentation.ScalarAndUnitConstructor());
            Builder.AppendLine($"{indentation}public {Data.Scalar.Name}(Scalar magnitude, {Data.Unit.Name} {Data.Unit.ParameterName})");
            Builder.AppendLine($"{indentation.Increased}: this({ConstructorComputation()}) {{ }}");

            Builder.AppendLine();

            AppendDocumentation(indentation, Data.Documentation.InUnit());
            Builder.AppendLine($"{indentation}public Scalar InUnit({Data.Unit.Name} {Data.Unit.ParameterName})");
            Builder.AppendLine($"{indentation.Increased}=> new({InUnitComputation()});");

            Builder.AppendLine();

            AppendToString(indentation);

            Builder.AppendLine();

            AppendComparable(indentation);
        }

        private string ConstructorComputation()
        {
            string unitMagnitude = $"{Data.Unit.ParameterName}.{Data.UnitQuantity.Name}.Magnitude.Value";

            if (Data.Biased)
            {
                return $"(magnitude - {Data.Unit.ParameterName}.Offset) * {unitMagnitude}";
            }

            return $"magnitude * {unitMagnitude}";
        }

        private string InUnitComputation()
        {
            string scaled = $"Magnitude.Value / {Data.Unit.ParameterName}.{Data.Unit.ParameterName}.Magnitude.Value";

            if (Data.Biased)
            {
                return $"{scaled} + {Data.Unit.ParameterName}.Offset";
            }

            return scaled;
        }

        private void AppendToString(Indentation indentation)
        {
            AppendDocumentation(indentation, Data.Documentation.ToStringDocumentation());
            Builder.Append($@"{indentation}public override string ToString() => $""{{typeof({Data.Scalar.Name})}}: [{{");

            if (Data.DefaultUnitName is not null)
            {
                Builder.Append($"InUnit({Data.Unit.Name}.{Data.DefaultUnitName}).Value");
            }
            else
            {
                Builder.Append("Magnitude.Value");
            }

            Builder.Append('}');

            if (Data.DefaultUnitSymbol is not null)
            {
                Builder.Append($" [{Data.DefaultUnitSymbol}]");
            }

            Builder.AppendLine($"\"");
        }

        private void AppendComparable(Indentation indentation)
        {
            AppendDocumentation(indentation, Data.Documentation.CompareToSameType());
            Builder.AppendLine($"{indentation}public int CompareTo({Data.Scalar.Name} other) => Magnitude.Value.CompareTo(other.Magnitude.Value);");

            Builder.AppendLine();

            AppendDocumentation(indentation, Data.Documentation.LessThanSameType());
            Builder.AppendLine($"{indentation}public static bool operator <({Data.Scalar.Name} x, {Data.Scalar.Name} y) " +
                $"=> x.Magnitude.Value < y.Magnitude.Value;");
            AppendDocumentation(indentation, Data.Documentation.GreaterThanSameType());
            Builder.AppendLine($"{indentation}public static bool operator >({Data.Scalar.Name} x, {Data.Scalar.Name} y) " +
                $"=> x.Magnitude.Value > y.Magnitude.Value;");
            AppendDocumentation(indentation, Data.Documentation.LessThanOrEqualSameType());
            Builder.AppendLine($"{indentation}public static bool operator <=({Data.Scalar.Name} x, {Data.Scalar.Name} y) " +
                $"=> x.Magnitude.Value <= y.Magnitude.Value;");
            AppendDocumentation(indentation, Data.Documentation.GreaterThanOrEqualSameType());
            Builder.AppendLine($"{indentation}public static bool operator >=({Data.Scalar.Name} x, {Data.Scalar.Name} y) " +
                $"=> x.Magnitude.Value >= y.Magnitude.Value;");
        }

        private void AppendDocumentation(Indentation indentation, string text)
        {
            DocumentationBuilding.AppendDocumentation(Builder, indentation, text);
        }
    }
}
