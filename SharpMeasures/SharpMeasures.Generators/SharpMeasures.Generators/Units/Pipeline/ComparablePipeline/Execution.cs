namespace SharpMeasures.Generators.Units.Pipeline.ComparablePipeline;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

using SharpMeasures.Generators.Documentation;
using SharpMeasures.Generators.SourceBuilding;
using SharpMeasures.Generators.Utility;

using System;
using System.Text;

internal static class Execution
{
    public static void Execute(SourceProductionContext context, Stage4.Result result)
    {
        string source = Composer.Compose(context, result);

        context.AddSource($"{result.TypeDefinition.Name}_Comparable.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private class Composer
    {
        public static string Compose(SourceProductionContext context, Stage4.Result data)
        {
            Composer composer = new(context, data);
            composer.Compose();
            return composer.Retrieve();
        }

        private SourceProductionContext Context { get; }
        private DocumentationFile Documentation { get; }
        private StringBuilder Builder { get; } = new();

        private DefinedType UnitType { get; }
        private NamedType QuantityType { get; }

        private Composer(SourceProductionContext context, Stage4.Result data)
        {
            Context = context;
            Documentation = data.Documentation;

            UnitType = data.TypeDefinition;
            QuantityType = data.Quantity;
        }

        private void Compose()
        {
            StaticBuilding.AppendAutoGeneratedHeader(Builder);
            StaticBuilding.AppendNullableDirective(Builder);

            NamespaceBuilding.AppendNamespace(Builder, UnitType.Namespace);

            UsingsBuilding.AppendUsings(Builder, new string[]
            {
            "System"
            });

            Builder.Append(UnitType.ComposeDeclaration());

            InterfaceBuilding.AppendInterfaceImplementation(Builder, new string[]
            {
            $"IComparable<{UnitType.Name}>"
            });

            BlockBuilding.AppendBlock(Builder, ComposeTypeBlock, originalIndentationLevel: 0);
        }

        private string Retrieve()
        {
            return Builder.ToString();
        }

        private void ComposeTypeBlock(StringBuilder source, Indentation indentation)
        {
            DocumentationBuilding.AppendDocumentation(Context, source, Documentation, indentation, "CompareTo_SameType");
            source.Append($"{indentation}public int CompareTo({UnitType.Name} other) " +
                $"=> {QuantityType.Name}.CompareTo(other.{QuantityType.Name});{Environment.NewLine}");

            source.Append(Environment.NewLine);
            DocumentationBuilding.AppendDocumentation(Context, source, Documentation, indentation, "Operator_LessThan_SameType");
            source.Append($"{indentation}public static bool operator <(UnitOfLength x, UnitOfLength y) => x.Length < y.Length;{Environment.NewLine}");
            DocumentationBuilding.AppendDocumentation(Context, source, Documentation, indentation, "Operator_GreaterThan_SameType");
            source.Append($"{indentation}public static bool operator >(UnitOfLength x, UnitOfLength y) => x.Length > y.Length;{Environment.NewLine}");
            DocumentationBuilding.AppendDocumentation(Context, source, Documentation, indentation, "Operator_LessThanOrEqual_SameType");
            source.Append($"{indentation}public static bool operator <=(UnitOfLength x, UnitOfLength y) => x.Length <= y.Length;{Environment.NewLine}");
            DocumentationBuilding.AppendDocumentation(Context, source, Documentation, indentation, "Operator_GreaterThanOrEqual_SameType");
            source.Append($"{indentation}public static bool operator >=(UnitOfLength x, UnitOfLength y) => x.Length >= y.Length;");
        }
    }
}
