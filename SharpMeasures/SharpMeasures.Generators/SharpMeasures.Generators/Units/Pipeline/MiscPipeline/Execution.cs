namespace SharpMeasures.Generators.Units.Pipeline.MiscPipeline;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

using SharpMeasures.Generators.Documentation;
using SharpMeasures.Generators.SourceBuilding;
using SharpMeasures.Generators.Utility;

using System;
using System.Text;

internal static class Execution
{
    public static void Execute(SourceProductionContext context, Stage4.Result result)
    {
        string source = Composer.Compose(context, result);

        context.AddSource($"{result.TypeDefinition.Name}_Misc.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private class Composer
    {
        public static string Compose(SourceProductionContext context, Stage4.Result data)
        {
            Composer composer = new(context, data);
            composer.Compose();
            return composer.Retrieve();
        }

        private SourceProductionContext Context { get; }
        private DocumentationFile Documentation { get; }
        private StringBuilder Builder { get; } = new();

        private DefinedType UnitType { get; }
        private NamedType QuantityType { get; }
        private bool Biased { get; }

        private Composer(SourceProductionContext context, Stage4.Result data)
        {
            Context = context;
            Documentation = data.Documentation;

            UnitType = data.TypeDefinition;
            Biased = data.Biased;
        }

        private void Compose()
        {
            StaticBuilding.AppendAutoGeneratedHeader(Builder);
            StaticBuilding.AppendNullableDirective(Builder);

            NamespaceBuilding.AppendNamespace(Builder, UnitType.Namespace);

            Builder.Append(UnitType.ComposeDeclaration());

            BlockBuilding.AppendBlock(Builder, ComposeTypeBlock, originalIndentationLevel: 0);
        }

        private string Retrieve()
        {
            return Builder.ToString();
        }

        private void ComposeTypeBlock(StringBuilder source, Indentation indentation)
        {
            if (Biased)
            {
                ComposeBiasedTypeBlock(indentation);
            }
            else
            {
                ComposeUnbiasedTypeBlock(indentation);
            }
        }

        private void ComposeUnbiasedTypeBlock(Indentation indentation)
        {
            DocumentationBuilding.AppendDocumentation(Context, Builder, Documentation, indentation, "Quantity");
            Builder.Append($"{indentation}public {QuantityType.FullyQualifiedName} {QuantityType.Name} {{ get; }}{Environment.NewLine}");

            DocumentationBuilding.AppendDocumentation(Context, Builder, Documentation, indentation, "Constructor");
            BlockBuilding.AppendBlock(Builder,
                header: $"private {UnitType.Name}({QuantityType.FullyQualifiedName} {QuantityType.ParameterName})",
                blockContentAppender: constructorBlock,
                originalIndentationLevel: indentation.Level);

            void constructorBlock(StringBuilder source, Indentation indentation)
            {
                Builder.Append($"{indentation}{QuantityType.Name} = {QuantityType.ParameterName};");
            }

            Builder.Append(Environment.NewLine);
            DocumentationBuilding.AppendDocumentation(Context, Builder, Documentation, indentation, "ScaledBy_Scalar");
            Builder.Append($"{indentation}public {UnitType.Name} ScaledBy(SharpMeasures.Scalar scale) => ScaledBy(scale.Value);{Environment.NewLine}");
            DocumentationBuilding.AppendDocumentation(Context, Builder, Documentation, indentation, "ScaledBy_Double");
            Builder.Append($"{indentation}public {UnitType.Name} ScaledBy(double scale) => new({QuantityType.Name} * scale);{Environment.NewLine}");

            Builder.Append(Environment.NewLine);
            DocumentationBuilding.AppendDocumentation(Context, Builder, Documentation, indentation, "WithPrefix_Metric");
            Builder.Append($"{indentation}public {UnitType.Name} WithPrefix(SharpMeasures.MetricPrefix prefix) => ScaledBy(prefix.Factor);{Environment.NewLine}");
            DocumentationBuilding.AppendDocumentation(Context, Builder, Documentation, indentation, "WithPrefix_Binary");
            Builder.Append($"{indentation}public {UnitType.Name} WithPrefix(SharpMeasures.BinaryPrefix prefix) => ScaledBy(prefix.Factor);{Environment.NewLine}");

            Builder.Append(Environment.NewLine);
            DocumentationBuilding.AppendDocumentation(Context, Builder, Documentation, indentation, "ToString");
            Builder.Append($"{indentation}public override string ToString() => $\"{{typeof({UnitType.Name})}}: {{{QuantityType.Name}}}\";{Environment.NewLine}");
        }
    }

    private static void ComposeBiased(SourceProductionContext context, Stage4.Result data, StringBuilder source, Indentation indentation, Names names)
    {
        DocumentationBuilding.AppendDocumentation(context, source, data.Documentation, indentation, "Quantity");
        source.Append($"{indentation}public {names.QuantityType} {names.Quantity} {{ get; }}{Environment.NewLine}");
        DocumentationBuilding.AppendDocumentation(context, source, data.Documentation, indentation, "Offset");
        source.Append($"{indentation}public Scalar Offset {{ get; }}{Environment.NewLine}");

        DocumentationBuilding.AppendDocumentation(context, source, data.Documentation, indentation, "Constructor");
        BlockBuilding.AppendBlock(source,
            header: $"private {names.Unit}({names.QuantityType} {names.QuantityParameter}, Scalar offset)",
            blockContentAppender: constructorBlock,
            originalIndentationLevel: indentation.Level);

        void constructorBlock(StringBuilder source, Indentation indentation)
        {
            source.Append($"{indentation}{names.Quantity} = {names.QuantityParameter};{Environment.NewLine}");
            source.Append($"{indentation}Offset = offset;");
        }

        source.Append(Environment.NewLine);
        DocumentationBuilding.AppendDocumentation(context, source, data.Documentation, indentation, "ScaledBy_Scalar");
        source.Append($"{indentation}public {names.Unit} ScaledBy(SharpMeasures.Scalar scale) => ScaledBy(scale.Value);{Environment.NewLine}");
        DocumentationBuilding.AppendDocumentation(context, source, data.Documentation, indentation, "ScaledBy_Double");
        source.Append($"{indentation}public {names.Unit} ScaledBy(double scale) => new({names.Quantity} * scale, Offset / scale);{Environment.NewLine}");

        source.Append(Environment.NewLine);
        DocumentationBuilding.AppendDocumentation(context, source, data.Documentation, indentation, "OffsetBy_Scalar");
        source.Append($"{indentation}public {names.Unit} OffsetBy(SharpMeasures.Scalar offset) => OffsetBy(offset.Value);{Environment.NewLine}");
        DocumentationBuilding.AppendDocumentation(context, source, data.Documentation, indentation, "OffsetBy_Double");
        source.Append($"{indentation}public {names.Unit} OffsetBy(double offset) => new({names.Quantity}, Offset + offset);{Environment.NewLine}");

        source.Append(Environment.NewLine);
        DocumentationBuilding.AppendDocumentation(context, source, data.Documentation, indentation, "WithPrefix_Metric");
        source.Append($"{indentation}public {names.Unit} WithPrefix(SharpMeasures.MetricPrefix prefix) => ScaledBy(prefix.Factor);{Environment.NewLine}");
        DocumentationBuilding.AppendDocumentation(context, source, data.Documentation, indentation, "WithPrefix_Binary");
        source.Append($"{indentation}public {names.Unit} WithPrefix(SharpMeasures.BinaryPrefix prefix) => ScaledBy(prefix.Factor);{Environment.NewLine}");

        source.Append(Environment.NewLine);
        DocumentationBuilding.AppendDocumentation(context, source, data.Documentation, indentation, "ToString");
        source.Append($"{indentation}public override string ToString() => $\"{{typeof({names.Unit})}}: ({{{names.Quantity}}} + {{Offset}})\";{Environment.NewLine}");
    }
}
