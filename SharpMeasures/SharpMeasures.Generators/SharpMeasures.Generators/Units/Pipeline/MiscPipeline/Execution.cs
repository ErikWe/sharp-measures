namespace SharpMeasures.Generators.Units.Pipeline.MiscPipeline;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

using SharpMeasures.Generators.SourceBuilding;

using System;
using System.Text;

internal static class Execution
{
    public static void Execute(SourceProductionContext context, Stage4.Result result)
    {
        string source = Compose(context, result);

        context.AddSource($"{result.TypeDefinition.Name.Name}_Misc.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private static string Compose(SourceProductionContext context, Stage4.Result data)
    {
        StringBuilder source = new();

        string unitName = data.TypeDefinition.Name.Name;
        string quantityName = data.Quantity.Name;
        string quantityParameterName = SourceBuildingUtility.ToParameterName(quantityName);
        string quantityType = data.Quantity.FullyQualifiedName;

        Names names = new(unitName, quantityName, quantityParameterName, quantityType);

        StaticBuilding.AppendAutoGeneratedHeader(source);
        StaticBuilding.AppendNullableDirective(source);

        NamespaceBuilding.AppendNamespace(source, data.TypeDefinition.Name.NameSpace);

        source.Append(data.TypeDefinition.ComposeDeclaration());

        BlockBuilding.AppendBlock(source, typeBlock, originalIndentationLevel: 0);

        void typeBlock(StringBuilder source, Indentation indentation)
        {
            if (data.Biased)
            {
                ComposeBiased(context, data, source, indentation, names);
            }
            else
            {
                ComposeUnbiased(context, data, source, indentation, names);
            }
        }

        return source.ToString();
    }

    private static void ComposeUnbiased(SourceProductionContext context, Stage4.Result data, StringBuilder source, Indentation indentation, Names names)
    {
        DocumentationBuilding.AppendDocumentation(context, source, data.Documentation, indentation, "Quantity");
        source.Append($"{indentation}public {names.QuantityType} {names.Quantity} {{ get; }}{Environment.NewLine}");

        DocumentationBuilding.AppendDocumentation(context, source, data.Documentation, indentation, "Constructor");
        BlockBuilding.AppendBlock(source,
            header: $"private {names.Unit}({names.QuantityType} {names.QuantityParameter})",
            blockContentAppender: constructorBlock,
            originalIndentationLevel: indentation.Level);

        void constructorBlock(StringBuilder source, Indentation indentation)
        {
            source.Append($"{indentation}{names.Quantity} = {names.QuantityParameter};");
        }

        source.Append(Environment.NewLine);
        DocumentationBuilding.AppendDocumentation(context, source, data.Documentation, indentation, "ScaledBy_Scalar");
        source.Append($"{indentation}public {names.Unit} ScaledBy(SharpMeasures.Scalar scale) => ScaledBy(scale.Value);{Environment.NewLine}");
        DocumentationBuilding.AppendDocumentation(context, source, data.Documentation, indentation, "ScaledBy_Double");
        source.Append($"{indentation}public {names.Unit} ScaledBy(double scale) => new({names.Quantity} * scale);{Environment.NewLine}");

        source.Append(Environment.NewLine);
        DocumentationBuilding.AppendDocumentation(context, source, data.Documentation, indentation, "WithPrefix_Metric");
        source.Append($"{indentation}public {names.Unit} WithPrefix(SharpMeasures.MetricPrefix prefix) => ScaledBy(prefix.Factor);{Environment.NewLine}");
        DocumentationBuilding.AppendDocumentation(context, source, data.Documentation, indentation, "WithPrefix_Binary");
        source.Append($"{indentation}public {names.Unit} WithPrefix(SharpMeasures.BinaryPrefix prefix) => ScaledBy(prefix.Factor);{Environment.NewLine}");

        source.Append(Environment.NewLine);
        DocumentationBuilding.AppendDocumentation(context, source, data.Documentation, indentation, "ToString");
        source.Append($"{indentation}public override string ToString() => $\"{{typeof({names.Unit})}}: {{{names.Quantity}}}\";{Environment.NewLine}");
    }

    private static void ComposeBiased(SourceProductionContext context, Stage4.Result data, StringBuilder source, Indentation indentation, Names names)
    {
        DocumentationBuilding.AppendDocumentation(context, source, data.Documentation, indentation, "Quantity");
        source.Append($"{indentation}public {names.QuantityType} {names.Quantity} {{ get; }}{Environment.NewLine}");
        DocumentationBuilding.AppendDocumentation(context, source, data.Documentation, indentation, "Offset");
        source.Append($"{indentation}public Scalar Offset {{ get; }}{Environment.NewLine}");

        DocumentationBuilding.AppendDocumentation(context, source, data.Documentation, indentation, "Constructor");
        BlockBuilding.AppendBlock(source,
            header: $"private {names.Unit}({names.QuantityType} {names.QuantityParameter}, Scalar offset)",
            blockContentAppender: constructorBlock,
            originalIndentationLevel: indentation.Level);

        void constructorBlock(StringBuilder source, Indentation indentation)
        {
            source.Append($"{indentation}{names.Quantity} = {names.QuantityParameter};{Environment.NewLine}");
            source.Append($"{indentation}Offset = offset;");
        }

        source.Append(Environment.NewLine);
        DocumentationBuilding.AppendDocumentation(context, source, data.Documentation, indentation, "ScaledBy_Scalar");
        source.Append($"{indentation}public {names.Unit} ScaledBy(SharpMeasures.Scalar scale) => ScaledBy(scale.Value);{Environment.NewLine}");
        DocumentationBuilding.AppendDocumentation(context, source, data.Documentation, indentation, "ScaledBy_Double");
        source.Append($"{indentation}public {names.Unit} ScaledBy(double scale) => new({names.Quantity} * scale, Offset / scale);{Environment.NewLine}");

        source.Append(Environment.NewLine);
        DocumentationBuilding.AppendDocumentation(context, source, data.Documentation, indentation, "OffsetBy_Scalar");
        source.Append($"{indentation}public {names.Unit} OffsetBy(SharpMeasures.Scalar offset) => OffsetBy(offset.Value);{Environment.NewLine}");
        DocumentationBuilding.AppendDocumentation(context, source, data.Documentation, indentation, "OffsetBy_Double");
        source.Append($"{indentation}public {names.Unit} OffsetBy(double offset) => new({names.Quantity}, Offset + offset);{Environment.NewLine}");

        source.Append(Environment.NewLine);
        DocumentationBuilding.AppendDocumentation(context, source, data.Documentation, indentation, "WithPrefix_Metric");
        source.Append($"{indentation}public {names.Unit} WithPrefix(SharpMeasures.MetricPrefix prefix) => ScaledBy(prefix.Factor);{Environment.NewLine}");
        DocumentationBuilding.AppendDocumentation(context, source, data.Documentation, indentation, "WithPrefix_Binary");
        source.Append($"{indentation}public {names.Unit} WithPrefix(SharpMeasures.BinaryPrefix prefix) => ScaledBy(prefix.Factor);{Environment.NewLine}");

        source.Append(Environment.NewLine);
        DocumentationBuilding.AppendDocumentation(context, source, data.Documentation, indentation, "ToString");
        source.Append($"{indentation}public override string ToString() => $\"{{typeof({names.Unit})}}: ({{{names.Quantity}}} + {{Offset}})\";{Environment.NewLine}");
    }

    private readonly record struct Names(string Unit, string Quantity, string QuantityParameter, string QuantityType);
}
