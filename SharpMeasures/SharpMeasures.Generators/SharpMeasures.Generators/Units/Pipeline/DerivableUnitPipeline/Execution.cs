namespace SharpMeasures.Generators.Units.Pipeline.DerivableUnitPipeline;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

using SharpMeasures.Generators.Attributes.Parsing.Units;
using SharpMeasures.Generators.Diagnostics.DerivableUnits;
using SharpMeasures.Generators.Documentation;
using SharpMeasures.Generators.SourceBuilding;
using SharpMeasures.Generators.Utility;

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;

internal static class Execution
{
    public static void Execute(SourceProductionContext context, Stage4.Result result)
    {
        string source = Composer.ComposeAndReportDiagnostics(context, result);

        if (string.IsNullOrEmpty(source))
        {
            return;
        }

        context.AddSource($"{result.TypeDefinition.Name}_Derivable.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private class Composer
    {
        public static string ComposeAndReportDiagnostics(SourceProductionContext context, Stage4.Result data)
        {
            Composer composer = new(context, data);
            composer.Compose();
            composer.ReportDiagnostics();
            return composer.Retrieve();
        }

        private SourceProductionContext Context { get; }
        private TypeDeclarationSyntax Declaration { get; }
        private DocumentationFile Documentation { get; }
        private StringBuilder Builder { get; } = new();

        private DefinedType UnitType { get; }
        private IEnumerable<DerivableUnitParameters> DefinedDerivations { get; }

        private HashSet<string> ImplementedDefinitions { get; } = new();
        private List<Diagnostic> Diagnostics { get; } = new();

        private Composer(SourceProductionContext context, Stage4.Result data)
        {
            Context = context;
            Declaration = data.Declaration.TypeDeclaration;
            Documentation = data.Documentation;

            UnitType = data.TypeDefinition;
            DefinedDerivations = data.DefinedDerivations;
        }

        private void Compose()
        {
            StaticBuilding.AppendAutoGeneratedHeader(Builder);
            StaticBuilding.AppendNullableDirective(Builder);

            NamespaceBuilding.AppendNamespace(Builder, UnitType);

            Builder.Append(UnitType.ComposeDeclaration());

            BlockBuilding.AppendBlock(Builder, ComposeTypeBlock, originalIndentationLevel: 0);
        }

        private void ComposeTypeBlock(StringBuilder source, Indentation indentation)
        {
            foreach (DerivableUnitParameters parameters in DefinedDerivations)
            {
                ComposeDefinition(parameters, indentation);
            }
        }

        private void ComposeDefinition(DerivableUnitParameters parameters, Indentation indentation)
        {
            IEnumerable<string> parameterNames = GetSignatureParameterNames(parameters.Signature);
            IEnumerable<string> signatureComponents = GetSignatureComponents(parameters.Signature, parameterNames);

            string tag = GetDocumentationTag(signatureComponents);

            if (ImplementedDefinitions.Contains(tag))
            {
                CreateDuplicateDerivableDefinitionDiagnostics(signatureComponents);
                return;
            }

            ImplementedDefinitions.Add(tag);

            DocumentationBuilding.AppendDocumentation(Context, Builder, Documentation, indentation, tag);
            Builder.Append($"{indentation}public static {UnitType.Name} From(");
            IterativeBuilding.AppendEnumerable(Builder, signatureComponents, ", ");
            Builder.Append($") => new({ParseExpression(parameters, parameterNames)});{Environment.NewLine}");
        }

        private void ReportDiagnostics()
        {
            Context.ReportDiagnostics(Diagnostics);
        }

        private string Retrieve()
        {
            if (ImplementedDefinitions.Count is 0)
            {
                return string.Empty;
            }
            else
            {
                return Builder.ToString();
            }
        }

        private void CreateDuplicateDerivableDefinitionDiagnostics(IEnumerable<string> signatureComponents)
        {
            StringBuilder signature = new();
            IterativeBuilding.AppendEnumerable(signature, "[", signatureComponents, ",", "]");

            Diagnostics.Add(DuplicateUnitDerivationSignatureDiagnostics.Create(Declaration, signature.ToString()));
        }

        private static IEnumerable<string> GetSignatureParameterNames(IEnumerable<INamedTypeSymbol> signature)
        {
            Dictionary<string, int> counts = new();

            foreach (string signatureComponentName in signatureWithoutNamespaces())
            {
                countParameter(signatureComponentName);
            }

            foreach (string signatureComponentName in signatureWithoutNamespaces())
            {
                yield return $"{SourceBuildingUtility.ToParameterName(signatureComponentName)}{getParameterNumber(signatureComponentName)}";
            }

            IEnumerable<string> signatureWithoutNamespaces()
            {
                foreach (INamedTypeSymbol signatureComponent in signature)
                {
                    yield return signatureComponent.Name.Substring(signatureComponent.Name.LastIndexOf('.') + 1);
                }
            }

            void countParameter(string signatureComponentName)
            {
                if (counts.TryGetValue(signatureComponentName, out int count))
                {
                    counts[signatureComponentName] = count - 1;
                }
                else
                {
                    counts[signatureComponentName] = -1;
                }
            }

            string getParameterNumber(string signatureComponentName)
            {
                int count = counts[signatureComponentName];

                if (count == -1)
                {
                    return string.Empty;
                }
                else if (count < 0)
                {
                    counts[signatureComponentName] = 1;
                    return "1";
                }
                else
                {
                    counts[signatureComponentName] += 1;
                    return counts[signatureComponentName].ToString(CultureInfo.InvariantCulture);
                }
            }
        }

        private static IEnumerable<string> GetSignatureComponents(IEnumerable<INamedTypeSymbol> signature, IEnumerable<string> parameterNames)
        {
            IEnumerator<INamedTypeSymbol> signatureIterator = signature.GetEnumerator();
            IEnumerator<string> parameterIterator = parameterNames.GetEnumerator();

            while (parameterIterator.MoveNext() && signatureIterator.MoveNext())
            {
                yield return $"{signatureIterator.Current.Name} {parameterIterator.Current}";
            }
        }

        private static string GetDocumentationTag(IEnumerable<string> signature)
        {
            StringBuilder tag = new("From");

            foreach (string component in signature)
            {
                tag.Append($"_{component}");
            }

            return tag.ToString();
        }

        private static string ParseExpression(DerivableUnitParameters parameters, IEnumerable<string> parameterNames)
        {
            string[] symbols = expressionComponents();

            return string.Format(CultureInfo.InvariantCulture, parameters.Expression, symbols);

            string[] expressionComponents()
            {
                string[] symbols = new string[parameters.Signature.Count];

                IEnumerator<string?> quantityIterator = quantitiesWithoutNamespaces().GetEnumerator();
                IEnumerator<string> parameterIterator = parameterNames.GetEnumerator();

                int index = 0;
                while (quantityIterator.MoveNext() && parameterIterator.MoveNext())
                {
                    symbols[index] = $"{parameterIterator.Current}.{quantityIterator.Current}";
                }

                return symbols;
            }

            IEnumerable<string> quantitiesWithoutNamespaces()
            {
                foreach (INamedTypeSymbol signatureComponentQuantity in parameters.Quantities)
                {
                    yield return signatureComponentQuantity.Name.Substring(signatureComponentQuantity.Name.LastIndexOf('.') + 1);
                }
            }
        }
    }
}
