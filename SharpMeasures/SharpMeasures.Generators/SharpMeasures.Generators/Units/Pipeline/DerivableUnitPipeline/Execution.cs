namespace SharpMeasures.Generators.Units.Pipeline.DerivableUnitPipeline;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

using SharpMeasures.Generators.Attributes.Parsing.Units;
using SharpMeasures.Generators.SourceBuilding;

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using System.Threading;

internal static class Execution
{
    public static void Execute(SourceProductionContext context, Stage4.Result result)
    {
        string source = Compose(result, context.CancellationToken);

        if (string.IsNullOrEmpty(source))
        {
            return;
        }

        context.AddSource($"{result.TypeDefinition.Name.Name}_Derivable.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private static string Compose(Stage4.Result data, CancellationToken _)
    {
        StringBuilder source = new();

        string unitName = data.TypeDefinition.Name.Name;
        bool anyDerivations = false;

        StaticBuilding.AppendAutoGeneratedHeader(source);
        StaticBuilding.AppendNullableDirective(source);

        NamespaceBuilding.AppendNamespace(source, data.TypeDefinition.Name.NameSpace);

        source.Append(data.TypeDefinition.ComposeDeclaration());

        BlockBuilding.AppendBlock(source, typeBlock, originalIndentationLevel: 0);

        void typeBlock(StringBuilder source, Indentation indentation)
        {
            foreach (DerivableUnitParameters derivation in data.DefinedDerivations)
            {
                anyDerivations = true;

                IEnumerable<string> parameterNames = GetSignatureParameterNames(derivation.Signature);
                IEnumerable<string> signatureComponents = GetSignatureNamedTypes(derivation.Signature, parameterNames);

                source.Append($"{indentation}public static {unitName} From(");
                IterativeBuilding.AppendEnumerable(source, signatureComponents, ", ");
                source.Append($") => new({ParseExpression(derivation, parameterNames)});{Environment.NewLine}");
            }
        }

        if (anyDerivations)
        {
            return source.ToString();
        }
        else
        {
            return string.Empty;
        }
    }

    private static IEnumerable<string> GetSignatureParameterNames(IEnumerable<INamedTypeSymbol> signature)
    {
        Dictionary<string, int> counts = new();

        foreach (string signatureComponentName in signatureWithoutNamespaces())
        {
            countParameter(signatureComponentName);
        }

        foreach (string signatureComponentName in signatureWithoutNamespaces())
        {
            yield return $"{SourceBuildingUtility.ToParameterName(signatureComponentName)}{getParameterNumber(signatureComponentName)}";
        }

        IEnumerable<string> signatureWithoutNamespaces()
        {
            foreach (INamedTypeSymbol signatureComponent in signature)
            {
                yield return signatureComponent.Name.Substring(signatureComponent.Name.LastIndexOf('.') + 1);
            }
        }

        void countParameter(string signatureComponentName)
        {
            if (counts.TryGetValue(signatureComponentName, out int count))
            {
                counts[signatureComponentName] = count - 1;
            }
            else
            {
                counts[signatureComponentName] = -1;
            }
        }

        string getParameterNumber(string signatureComponentName)
        {
            int count = counts[signatureComponentName];

            if (count == -1)
            {
                return string.Empty;
            }
            else if (count < 0)
            {
                counts[signatureComponentName] = 1;
                return "1";
            }
            else
            {
                counts[signatureComponentName] += 1;
                return counts[signatureComponentName].ToString(CultureInfo.InvariantCulture);
            }
        }
    }

    private static IEnumerable<string> GetSignatureNamedTypes(IEnumerable<INamedTypeSymbol> signature, IEnumerable<string> parameterNames)
    {
        IEnumerator<INamedTypeSymbol> signatureIterator = signature.GetEnumerator();
        IEnumerator<string> parameterIterator = parameterNames.GetEnumerator();

        while (parameterIterator.MoveNext() && signatureIterator.MoveNext())
        {
            yield return $"{signatureIterator.Current.Name} {parameterIterator.Current}";
        }
    }

    private static string ParseExpression(DerivableUnitParameters parameters, IEnumerable<string> parameterNames)
    {
        string[] symbols = expressionComponents();

        return string.Format(CultureInfo.InvariantCulture, parameters.Expression, symbols);

        string[] expressionComponents()
        {
            string[] symbols = new string[parameters.Signature.Count];

            IEnumerator<string?> quantityIterator = quantitiesWithoutNamespaces().GetEnumerator();
            IEnumerator<string> parameterIterator = parameterNames.GetEnumerator();

            int index = 0;
            while (quantityIterator.MoveNext() && parameterIterator.MoveNext())
            {
                symbols[index] = $"{parameterIterator.Current}.{quantityIterator.Current}";
            }

            return symbols;
        }

        IEnumerable<string> quantitiesWithoutNamespaces()
        {
            foreach (INamedTypeSymbol signatureComponentQuantity in parameters.Quantities)
            {
                yield return signatureComponentQuantity.Name.Substring(signatureComponentQuantity.Name.LastIndexOf('.') + 1);
            }
        }
    }
}
