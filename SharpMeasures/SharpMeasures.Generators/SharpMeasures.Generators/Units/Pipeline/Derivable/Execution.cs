namespace SharpMeasures.Generators.Units.Pipeline.Derivable;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

using SharpMeasures.Generators.SourceBuilding;

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;

internal static class Execution
{
    public static void Execute(SourceProductionContext context, DataModel data)
    {
        if (data.Derivations.Any() is false)
        {
            return;
        }

        string source = Composer.ComposeAndReportDiagnostics(context, data);

        context.AddSource($"{data.Unit.Name}_Derivable.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private class Composer
    {
        public static string ComposeAndReportDiagnostics(SourceProductionContext context, DataModel data)
        {
            Composer composer = new(context, data);
            composer.Compose();
            return composer.Retrieve();
        }

        private SourceProductionContext Context { get; }
        private StringBuilder Builder { get; } = new();
        private UsingsCollector UsingsCollector { get; }

        private DataModel Data { get; }

        private Composer(SourceProductionContext context, DataModel data)
        {
            Context = context;
            Data = data;
            UsingsCollector = UsingsCollector.Delayed(Builder, data.Unit.Namespace);
        }

        private void Compose()
        {
            StaticBuilding.AppendAutoGeneratedHeader(Builder);
            StaticBuilding.AppendNullableDirective(Builder);

            UsingsCollector.MarkInsertionPoint();

            NamespaceBuilding.AppendNamespace(Builder, Data.Unit);

            Builder.Append(Data.Unit.ComposeDeclaration());

            BlockBuilding.AppendBlock(Builder, ComposeTypeBlock, originalIndentationLevel: 0);

            UsingsCollector.InsertUsings();
        }

        private string Retrieve()
        {
            return Builder.ToString();
        }

        private void ComposeTypeBlock(Indentation indentation)
        {
            foreach (ExtendedDerivableUnitDefinition definition in Data.Derivations)
            {
                ComposeDefinition(definition, indentation);
            }
        }

        private void ComposeDefinition(ExtendedDerivableUnitDefinition definition, Indentation indentation)
        {
            IEnumerable<string> parameterNames = GetSignatureParameterNames(definition.Signature);
            IEnumerable<string> signatureComponents = GetSignatureComponents(definition.Signature, parameterNames);

            string signatureTag = GetUniqueTagForSignature(signatureComponents);

            DocumentationBuilding.AppendDocumentation(Context, Builder, Data.Documentation, indentation, DocumentationTags.Derivable.WithSignature(signatureTag));
            Builder.Append($"{indentation}public static {Data.Unit.Name} From(");
            IterativeBuilding.AppendEnumerable(Builder, signatureComponents, ", ");
            Builder.Append($") => new({ParseExpression(definition, parameterNames)});{Environment.NewLine}");
        }

        private static IEnumerable<string> GetSignatureParameterNames(IEnumerable<NamedType> signature)
        {
            Dictionary<string, int> counts = new();

            foreach (NamedType signatureComponent in signature)
            {
                countParameter(signatureComponent);
            }

            foreach (NamedType signatureComponent in signature)
            {
                yield return $"{SourceBuildingUtility.ToParameterName(signatureComponent.Name)}{getParameterNumber(signatureComponent.Name)}";
            }

            void countParameter(NamedType signatureComponent)
            {
                if (counts.TryGetValue(signatureComponent.Name, out int count))
                {
                    counts[signatureComponent.Name] = count - 1;
                }
                else
                {
                    counts[signatureComponent.Name] = -1;
                }
            }

            string getParameterNumber(string signatureComponentName)
            {
                int count = counts[signatureComponentName];

                if (count == -1)
                {
                    return string.Empty;
                }
                else if (count < 0)
                {
                    counts[signatureComponentName] = 1;
                    return "1";
                }
                else
                {
                    counts[signatureComponentName] += 1;
                    return counts[signatureComponentName].ToString(CultureInfo.InvariantCulture);
                }
            }
        }

        private IEnumerable<string> GetSignatureComponents(IEnumerable<NamedType> signature, IEnumerable<string> parameterNames)
        {
            IEnumerator<NamedType> signatureIterator = signature.GetEnumerator();
            IEnumerator<string> parameterIterator = parameterNames.GetEnumerator();

            while (parameterIterator.MoveNext() && signatureIterator.MoveNext())
            {
                UsingsCollector.AddUsing(signatureIterator.Current.Namespace);
                yield return $"{signatureIterator.Current.Name} {parameterIterator.Current}";
            }
        }

        private static string GetUniqueTagForSignature(IEnumerable<string> signature)
        {
            StringBuilder tag = new();

            IterativeBuilding.AppendEnumerable(tag, signature, "_");

            return tag.ToString();
        }

        private static string ParseExpression(ExtendedDerivableUnitDefinition definition, IEnumerable<string> parameterNames)
        {
            return string.Format(CultureInfo.InvariantCulture, definition.Expression, parameterNameAndQuantity().ToArray());

            IEnumerable<string> parameterNameAndQuantity()
            {
                int i = 0;

                foreach (string parameterName in parameterNames)
                {
                    yield return $"{parameterName}.{definition.QuantitiesOfSignatureUnits[i]}";
                    i += 1;
                }
            }
        }
    }
}
