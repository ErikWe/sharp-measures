namespace SharpMeasures.Generators.Units.Pipeline.UnitDefinitionsPipeline;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

using SharpMeasures.Generators.Attributes.Parsing.Units;
using SharpMeasures.Generators.SourceBuilding;

using System;
using System.Collections.Generic;
using System.Text;
using System.Threading;

internal static class Execution
{
    public static void Execute(SourceProductionContext context, Stage4.Result result)
    {
        string source = Compose(context, result, context.CancellationToken);

        if (string.IsNullOrEmpty(source))
        {
            return;
        }

        context.AddSource($"{result.TypeDefinition.Name}_Definitions.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private static string Compose(SourceProductionContext context, Stage4.Result data, CancellationToken _)
    {
        StringBuilder source = new();

        string unitName = data.TypeDefinition.Name;
        bool anyDefinitions = false;

        StaticBuilding.AppendAutoGeneratedHeader(source);
        StaticBuilding.AppendNullableDirective(source);

        NamespaceBuilding.AppendNamespace(source, data.TypeDefinition.Namespace);

        source.Append(data.TypeDefinition.ComposeDeclaration());

        BlockBuilding.AppendBlock(source, typeBlock, originalIndentationLevel: 0);

        void typeBlock(StringBuilder source, Indentation indentation)
        {
            HashSet<string> definedUnits = new();

            AppendDerived(context, data, source, indentation, definedUnits);
            AppendFixed(context, data, source, indentation, definedUnits);

            IList<IDependantUnitDefinitionParameters> dependantUnits
                = GetDependantInstances(data.UnitAliases, data.ScaledUnits, data.PrefixedUnits, data.OffsetUnits);

            AppendDependantUnits(context, data, source, indentation, dependantUnits, definedUnits);

            if (definedUnits.Count > 0)
            {
                anyDefinitions = true;
            }
        }

        if (anyDefinitions)
        {
            return source.ToString();
        }
        else
        {
            return string.Empty;
        }
    }

    private static void AppendDerived(SourceProductionContext context, Stage4.Result data, StringBuilder source, Indentation indentation,
        HashSet<string> definedUnits)
    {
        foreach (DerivedUnitParameters derivedUnit in data.DerivedUnits)
        {
            if (definedUnits.Contains(derivedUnit.Name))
            {
                continue;
            }

            definedUnits.Add(derivedUnit.Name);

            DocumentationBuilding.AppendDocumentation(context, source, data.Documentation, indentation, $"Definition_{data.TypeDefinition.Name}");
            source.Append($"{indentation}public static {data.TypeDefinition.Name} {derivedUnit.Name} {{ get; }} = ");

            IterativeBuilding.AppendEnumerable(source, "From(", arguments(), ", ", $");{Environment.NewLine}");

            IEnumerable<string> arguments()
            {
                IEnumerator<INamedTypeSymbol> signatureIterator = derivedUnit.Signature.GetEnumerator();
                IEnumerator<string> unitIterator = derivedUnit.Units.GetEnumerator();

                while (signatureIterator.MoveNext() && unitIterator.MoveNext())
                {
                    yield return $"{signatureIterator.Current}.{unitIterator.Current}";
                }
            }
        }
    }

    private static void AppendFixed(SourceProductionContext context, Stage4.Result data, StringBuilder source, Indentation indentation,
        HashSet<string> definedUnits)
    {
        Action<FixedUnitParameters> appender = data.Biased ? appendBiased : appendUnbiased;

        foreach (FixedUnitParameters fixedUnit in data.FixedUnits)
        {
            if (definedUnits.Contains(fixedUnit.Name))
            {
                continue;
            }

            definedUnits.Add(fixedUnit.Name);

            appender(fixedUnit);
        }

        void appendDeclaration(FixedUnitParameters fixedUnit)
        {
            DocumentationBuilding.AppendDocumentation(context, source, data.Documentation, indentation, $"Definition_{data.TypeDefinition.Name}");
            source.Append($"{indentation}public static {data.TypeDefinition.Name} {fixedUnit.Name} {{ get; }}");
        }

        void appendUnbiased(FixedUnitParameters fixedUnit)
        {
            appendDeclaration(fixedUnit);
            source.Append($" = new(new {data.Quantity.FullyQualifiedName}({fixedUnit.Value}));{Environment.NewLine}");
        }

        void appendBiased(FixedUnitParameters fixedUnit)
        {
            appendDeclaration(fixedUnit);
            source.Append($" = new(new {data.Quantity.FullyQualifiedName}({fixedUnit.Value}), new SharpMeasures.Scalar({fixedUnit.Bias}));{Environment.NewLine}");
        }
    }

    private static void AppendDependantUnits(SourceProductionContext context, Stage4.Result data, StringBuilder source, Indentation indentation,
         IList<IDependantUnitDefinitionParameters> dependantUnits, HashSet<string> definedUnits)
    {
        int initialLength = dependantUnits.Count;

        for (int i = 0; i < dependantUnits.Count; i++)
        {
            if (definedUnits.Contains(dependantUnits[i].Name))
            {
                dependantUnits.RemoveAt(i);
                i--;
                continue;
            }

            if (definedUnits.Contains(dependantUnits[i].DependantOn))
            {
                DocumentationBuilding.AppendDocumentation(context, source, data.Documentation, indentation, $"Definition_{data.TypeDefinition.Name}");
                source.Append($"{indentation}public static {data.TypeDefinition.Name} {dependantUnits[i].Name} ");

                if (dependantUnits[i] is UnitAliasParameters unitAlias)
                {
                    AppendAlias(source, unitAlias);
                }
                else if (dependantUnits[i] is ScaledUnitParameters scaledUnit)
                {
                    AppendScaled(source, scaledUnit);
                }
                else if (dependantUnits[i] is PrefixedUnitParameters prefixedUnit)
                {
                    AppendPrefixed(source, prefixedUnit);
                }
                else if (dependantUnits[i] is OffsetUnitParameters offsetUnit)
                {
                    AppendOffset(source, offsetUnit);
                }

                source.Append($";{Environment.NewLine}");
             
                definedUnits.Add(dependantUnits[i].Name);
                dependantUnits.RemoveAt(i);
                i--;
            }
        }

        if (dependantUnits.Count < initialLength)
        {
            AppendDependantUnits(context, data, source, indentation, dependantUnits, definedUnits);
        }
    }

    private static void AppendAlias(StringBuilder source, UnitAliasParameters unitAlias)
    {
        source.Append($"=> {unitAlias.AliasOf}");
    }

    private static void AppendScaled(StringBuilder source, ScaledUnitParameters scaledUnit)
    {
        source.Append($"{{ get; }} = {scaledUnit.From}.ScaledBy({scaledUnit.Scale})");
    }

    private static void AppendPrefixed(StringBuilder source, PrefixedUnitParameters prefixedUnit)
    {
        source.Append($"{{ get; }} = {prefixedUnit.From}.WithPrefix(SharpMeasures.{prefixText()})");

        string prefixText() => prefixedUnit.SpecifiedPrefixType switch
        {
            PrefixedUnitParameters.PrefixType.Metric => metricText(),
            PrefixedUnitParameters.PrefixType.Binary => binaryText(),
            _ => string.Empty
        };

        string metricText() => $"MetricPrefix.{prefixedUnit.MetricPrefixName}";
        string binaryText() => $"BinaryPrefix.{prefixedUnit.BinaryPrefixName}";
    }

    private static void AppendOffset(StringBuilder source, OffsetUnitParameters offsetUnit)
    {
        source.Append($"{{ get; }} = {offsetUnit.From}.ScaledBy({offsetUnit.Offset})");
    }

    private static IList<IDependantUnitDefinitionParameters> GetDependantInstances(IEnumerable<UnitAliasParameters> unitAliases,
        IEnumerable<ScaledUnitParameters> scaledUnits, IEnumerable<PrefixedUnitParameters> prefixedUnits,
        IEnumerable<OffsetUnitParameters> offsetUnits)
    {
        List<IDependantUnitDefinitionParameters> result = new();

        foreach (UnitAliasParameters unitAlias in unitAliases)
        {
            result.Add(unitAlias);
        }

        foreach (ScaledUnitParameters scaledUnit in scaledUnits)
        {
            result.Add(scaledUnit);
        }

        foreach (PrefixedUnitParameters prefixedUnit in prefixedUnits)
        {
            result.Add(prefixedUnit);
        }

        foreach (OffsetUnitParameters offsetUnit in offsetUnits)
        {
            result.Add(offsetUnit);
        }

        return result;
    }
}
