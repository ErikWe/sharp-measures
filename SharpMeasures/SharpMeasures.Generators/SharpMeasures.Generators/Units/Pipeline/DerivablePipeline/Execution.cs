namespace SharpMeasures.Generators.Units.Pipeline.DerivablePipeline;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

using SharpMeasures.Generators.Attributes.Parsing.Units.Caching;
using SharpMeasures.Generators.SourceBuilding;

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;

internal static class Execution
{
    public static void Execute(SourceProductionContext context, Stage4.Result result)
    {
        string source = Compose(result, context.CancellationToken);

        if (string.IsNullOrEmpty(source))
        {
            return;
        }

        context.AddSource($"{result.TypeDefinition.Name.Name}_Derivable.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private static string Compose(Stage4.Result data, CancellationToken _)
    {
        StringBuilder source = new();

        string unitName = data.TypeDefinition.Name.Name;
        bool anyDerivations = false;

        StaticBuilding.AppendAutoGeneratedHeader(source);
        StaticBuilding.AppendNullableDirective(source);

        NamespaceBuilding.AppendNamespace(source, data.TypeDefinition.Name.NameSpace);

        source.Append(data.TypeDefinition.ComposeDeclaration());

        BlockBuilding.AppendBlock(source, typeBlock, originalIndentationLevel: 0);

        void typeBlock(StringBuilder source, Indentation indentation)
        {
            foreach (CachedDerivableUnitAttributeParameters derivation in data.DefinedDerivations)
            {
                anyDerivations = true;

                IEnumerable<string> parameterNames = GetSignatureParameterNames(derivation.Signature);
                IEnumerable<string> signatureComponents = GetSignatureNamedTypes(derivation.Signature, parameterNames);

                source.Append($"{indentation}public static {unitName} From(");
                IterativeBuilding.AppendEnumerable(source, signatureComponents, ", ");
                source.Append($") => new({ParseExpression(derivation, parameterNames)});{Environment.NewLine}");
            }
        }

        if (anyDerivations)
        {
            return source.ToString();
        }
        else
        {
            return string.Empty;
        }
    }

    private static IEnumerable<string> GetSignatureParameterNames(IEnumerable<string?> signature)
    {
        Dictionary<string, int> counts = new();

        foreach (string symbol in signatureWithoutNamespaces())
        {
            countParameter(symbol);
        }

        foreach (string symbol in signatureWithoutNamespaces())
        {
            yield return $"{SourceBuildingUtility.ToParameterName(symbol)}{getParameterNumber(symbol)}";
        }

        IEnumerable<string> signatureWithoutNamespaces()
        {
            foreach (string? fullyQualifiedType in signature)
            {
                if (fullyQualifiedType is null)
                {
                    continue;
                }

                yield return fullyQualifiedType.Substring(fullyQualifiedType.LastIndexOf('.') + 1);
            }
        }

        void countParameter(string symbol)
        {
            if (counts.TryGetValue(symbol, out int count))
            {
                counts[symbol] = count - 1;
            }
            else
            {
                counts[symbol] = -1;
            }
        }

        string getParameterNumber(string symbol)
        {
            int count = counts[symbol];

            if (count == -1)
            {
                return string.Empty;
            }
            else if (count < 0)
            {
                counts[symbol] = 1;
                return "1";
            }
            else
            {
                counts[symbol] += 1;
                return counts[symbol].ToString(CultureInfo.InvariantCulture);
            }
        }
    }

    private static IEnumerable<string> GetSignatureNamedTypes(IEnumerable<string?> signature, IEnumerable<string> parameterNames)
    {
        IEnumerator<string?> signatureIterator = signature.GetEnumerator();
        IEnumerator<string> parameterIterator = parameterNames.GetEnumerator();

        while (parameterIterator.MoveNext() && signatureIterator.MoveNext())
        {
            yield return $"{signatureIterator.Current} {parameterIterator.Current}";
        }
    }

    private static string ParseExpression(CachedDerivableUnitAttributeParameters parameters, IEnumerable<string> parameterNames)
    {
        string expression = parameters.Expression;

        IEnumerator<string?> quantityIterator = quantitiesWithoutNamespaces().GetEnumerator();
        IEnumerator<string> parameterIterator = parameterNames.GetEnumerator();

        int index = 0;
        while (quantityIterator.MoveNext() && parameterIterator.MoveNext())
        {
            Regex regex = new($@"\{{{index++}\}}");
            expression = regex.Replace(expression, $"{parameterIterator.Current}.{quantityIterator.Current}");
        }

        return expression;

        IEnumerable<string> quantitiesWithoutNamespaces()
        {
            foreach (string? fullyQualifiedType in parameters.Quantities)
            {
                if (fullyQualifiedType is null)
                {
                    continue;
                }

                yield return fullyQualifiedType.Substring(fullyQualifiedType.LastIndexOf('.') + 1);
            }
        }
    }
}
