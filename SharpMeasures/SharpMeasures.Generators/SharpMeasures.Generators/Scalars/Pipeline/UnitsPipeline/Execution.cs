namespace SharpMeasures.Generators.Scalars.Pipeline.UnitsPipeline;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

using SharpMeasures.Generators.Diagnostics;
using SharpMeasures.Generators.SourceBuilding;
using SharpMeasures.Generators.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

internal static class Execution
{
    public static void Execute(SourceProductionContext context, DataModel data)
    {
        string source = Composer.Compose(context, data);

        context.AddSource($"{data.Scalar.Name}_Units.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private class Composer
    {
        public static string Compose(SourceProductionContext context, DataModel data)
        {
            Composer composer = new(context, data);
            composer.Compose();
            composer.ReportDiagnostics();
            return composer.Retrieve();
        }

        private SourceProductionContext Context { get; }
        private StringBuilder Builder { get; } = new();

        private DataModel Data { get; }
        private Dictionary<string, UnitName> ImplementedUnits { get; } = new();

        private List<Diagnostic> Diagnostics { get; } = new();

        private Composer(SourceProductionContext context, DataModel data)
        {
            Context = context;
            Data = data;
        }

        private void Compose()
        {
            StaticBuilding.AppendAutoGeneratedHeader(Builder);
            StaticBuilding.AppendNullableDirective(Builder);

            NamespaceBuilding.AppendNamespace(Builder, Data.Scalar.Namespace);

            UsingsBuilding.AppendUsings(Builder, Data.Scalar.Namespace, new string[]
            {
                "SharpMeasures",
                Data.Definition.Unit.Namespace
            });

            Builder.Append(Data.Scalar.ComposeDeclaration());

            BlockBuilding.AppendBlock(Builder, ComposeTypeBlock, originalIndentationLevel: 0);
        }

        private void ReportDiagnostics()
        {
            Context.ReportDiagnostics(Diagnostics);
        }

        private string Retrieve()
        {
            return Builder.ToString();
        }

        private void ComposeTypeBlock(Indentation indentation)
        {
            HashSet<string> implementedBases = new();

            foreach (UnitName includedBase in GetBases())
            {
                if (implementedBases.Contains(includedBase.Name))
                {
                    continue;
                }

                implementedBases.Add(includedBase.Name);

                AppendDocumentation(indentation, DocumentationTags.Units.BaseWithName(includedBase));
                Builder.Append($"{indentation}public static {Data.Scalar.Name} One{includedBase} {{ get; }} = " +
                    $"{Data.Definition.Unit.Name}.{includedBase.Name}.{Data.Definition.UnitDefinition?.Quantity.Name};{Environment.NewLine}");
            }

            Builder.Append(Environment.NewLine);

            foreach (UnitName includedUnit in GetUnits())
            {
                if (ImplementedUnits.ContainsKey(includedUnit.Name))
                {
                    continue;
                }

                ImplementedUnits.Add(includedUnit.Name, includedUnit);

                AppendDocumentation(indentation, DocumentationTags.Units.UnitWithName(includedUnit));
                Builder.Append($"{indentation}public static Scalar {includedUnit.Plural} => InUnit({Data.Definition.Unit.Name}.{includedUnit.Name});{Environment.NewLine}");
            }

            Builder.Append(Environment.NewLine);

            AppendToString(indentation);
        }

        private void AppendToString(Indentation indentation)
        {
            if (Data.Definition.DefaultUnitName is not null)
            {
                if (ImplementedUnits.TryGetValue(Data.Definition.DefaultUnitName, out UnitName unitName) is false)
                {
                    Diagnostic diagnostics = DiagnosticConstruction.UnitNameNotRecognized(Data.Definition.Locations.DefaultUnitName.ToLocation(),
                        Data.Definition.DefaultUnitName, Data.Definition.Unit.Name);

                    Diagnostics.Add(diagnostics);
                }

                string symbol = Data.Definition.DefaultUnitSymbol is not null
                    ? $"{Data.Definition.DefaultUnitSymbol}"
                    : $"{unitName.Plural}";

                AppendDocumentation(indentation, DocumentationTags.ToString);
                Builder.Append($"{indentation}public override string ToString() => " +
                    $@"$""{{typeof({Data.Scalar.Name})}}:{{{unitName.Plural}}} [{symbol}]"";{Environment.NewLine}");
            }
        }

        private IEnumerable<UnitName> GetBases()
        {
            if (Data.IncludedBases is not null)
            {
                return GetIncludedAndExisting(Data.IncludedBases.Value.IncludedBases);
            }

            if (Data.ExcludedBases is not null)
            {
                return GetExistingNotExcluded(Data.ExcludedBases.Value.ExcludedBases);
            }

            return Data.UnitNames;
        }

        private IEnumerable<UnitName> GetUnits()
        {
            if (Data.IncludedUnits is not null)
            {
                return GetIncludedAndExisting(Data.IncludedUnits.Value.IncludedUnits);
            }

            if (Data.ExcludedUnits is not null)
            {
                return GetExistingNotExcluded(Data.ExcludedUnits.Value.ExcludedUnits);
            }

            return Data.UnitNames;
        }

        private IEnumerable<UnitName> GetIncludedAndExisting(IReadOnlyList<string> included)
        {
            Dictionary<string, UnitName> existingUnits = Data.UnitNames.ToDictionary(static (x) => x.Name);

            foreach (string singularUnitName in included)
            {
                if (existingUnits.TryGetValue(singularUnitName, out UnitName unitName))
                {
                    yield return unitName;
                }
            }
        }

        private IEnumerable<UnitName> GetExistingNotExcluded(IReadOnlyList<string> excluded)
        {
            HashSet<string> excludedUnits = new(excluded);

            return iterator();

            IEnumerable<UnitName> iterator()
            {
                foreach (UnitName unitName in Data.UnitNames)
                {
                    if (excludedUnits.Contains(unitName.Name) is false)
                    {
                        yield return unitName;
                    }
                }
            }
        }

        private void AppendDocumentation(Indentation indentation, string tag)
        {
            DocumentationBuilding.AppendDocumentation(Context, Builder, Data.Documentation, indentation, tag);
        }
    }
}
