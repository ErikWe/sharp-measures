namespace SharpMeasures.Generators.Scalars.Pipeline.StandardMathsPipeline;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

using SharpMeasures.Generators.SourceBuilding;

using System;
using System.Text;

internal static class Execution
{
    public static void Execute(SourceProductionContext context, DataModel data)
    {
        string source = Composer.Compose(context, data);

        context.AddSource($"{data.Scalar.Name}_StandardMaths.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private class Composer
    {
        public static string Compose(SourceProductionContext context, DataModel data)
        {
            Composer composer = new(context, data);
            composer.Compose();
            return composer.Retrieve();
        }

        private SourceProductionContext Context { get; }
        private StringBuilder Builder { get; } = new();

        private DataModel Data { get; }

        private Composer(SourceProductionContext context, DataModel data)
        {
            Context = context;
            Data = data;
        }

        private void Compose()
        {
            StaticBuilding.AppendAutoGeneratedHeader(Builder);
            StaticBuilding.AppendNullableDirective(Builder);

            NamespaceBuilding.AppendNamespace(Builder, Data.Scalar.Namespace);

            UsingsBuilding.AppendUsings(Builder, Data.Scalar.Namespace, new string[]
            {
                "SharpMeasures"
            });

            Builder.Append(Data.Scalar.ComposeDeclaration());

            InterfaceBuilding.AppendInterfaceImplementation(Builder, new string[]
            {
                $"IScalableScalar<{Data.Scalar.Name}>",
                $"IMultiplicableScalar<{Data.Scalar.Name}, Scalar>",
                "IMultiplicableScalar<Unhandled, Unhandled>",
                $"IDivisibleScalar<{Data.Scalar.Name}, Scalar>",
                "IDivisibleScalarQuantity<Unhandled, Unhandled>",
                "IGenericallyMultiplicableScalarQuantity",
                "IGenericallyDivisibleScalarQuantity"
            });

            BlockBuilding.AppendBlock(Builder, ComposeTypeBlock, originalIndentationLevel: 0);
        }

        private string Retrieve()
        {
            return Builder.ToString();
        }

        private void ComposeTypeBlock(Indentation indentation)
        {
            AppendDocumentation(indentation, DocumentationTags.StandardMaths.IsNaN);
            Builder.Append($"{indentation}public bool IsNaN => double.IsNaN(Magnitude.Value);{Environment.NewLine}");
            AppendDocumentation(indentation, DocumentationTags.StandardMaths.IsZero);
            Builder.Append($"{indentation}public bool IsZero => Magnitude.Value is 0;{Environment.NewLine}");
            AppendDocumentation(indentation, DocumentationTags.StandardMaths.IsPositive);
            Builder.Append($"{indentation}public bool IsPositive => Magnitude.Value > 0;{Environment.NewLine}");
            AppendDocumentation(indentation, DocumentationTags.StandardMaths.IsNegative);
            Builder.Append($"{indentation}public bool IsNegative => Magnitude.Value < 0;{Environment.NewLine}");
            AppendDocumentation(indentation, DocumentationTags.StandardMaths.IsFinite);
            Builder.Append($"{indentation}public bool IsFinite => double.IsFinite(Magnitude.Value);{Environment.NewLine}");
            AppendDocumentation(indentation, DocumentationTags.StandardMaths.IsInfinity);
            Builder.Append($"{indentation}public bool IsInfinite => double.IsInfinity(Magnitude.Value);{Environment.NewLine}");
            AppendDocumentation(indentation, DocumentationTags.StandardMaths.IsPositiveInfinity);
            Builder.Append($"{indentation}public bool IsPositiveInfinity => double.IsPositiveInfinity(Magnitude.Value);{Environment.NewLine}");
            AppendDocumentation(indentation, DocumentationTags.StandardMaths.IsNegativeInfinity);
            Builder.Append($"{indentation}public bool IsNegativeInfinity => double.IsNegativeInfinity(Magnitude.Value);{Environment.NewLine}");

            Builder.Append(Environment.NewLine);

            AppendDocumentation(indentation, DocumentationTags.StandardMaths.Absolute);
            Builder.Append($"{indentation}public {Data.Scalar.Name} Absolute() => new(Math.Abs(Magnitude.Value));{Environment.NewLine}");
            AppendDocumentation(indentation, DocumentationTags.StandardMaths.Floor);
            Builder.Append($"{indentation}public {Data.Scalar.Name} Floor() => new(Math.Floor(Magnitude.Value));{Environment.NewLine}");
            AppendDocumentation(indentation, DocumentationTags.StandardMaths.Ceiling);
            Builder.Append($"{indentation}public {Data.Scalar.Name} Ceiling() => new(Math.Ceiling(Magnitude.Value));{Environment.NewLine}");
            AppendDocumentation(indentation, DocumentationTags.StandardMaths.Round);
            Builder.Append($"{indentation}public {Data.Scalar.Name} Round() => new(Math.Round(Magnitude.Value));{Environment.NewLine}");
            AppendDocumentation(indentation, DocumentationTags.StandardMaths.Truncate);
            Builder.Append($"{indentation}public {Data.Scalar.Name} Truncate() => new(Math.Truncate(Magnitude.Value));{Environment.NewLine}");

            Builder.Append(Environment.NewLine);

            AppendDocumentation(indentation, DocumentationTags.StandardMaths.Sign);
            Builder.Append($"public int Sign() => Math.Sign(Magnitude.Value);{Environment.NewLine}");

            Builder.Append(Environment.NewLine);

            AppendDocumentation(indentation, DocumentationTags.StandardMaths.UnaryPlus);
            Builder.Append($"{indentation}public {Data.Scalar.Name} Plus() => this;{Environment.NewLine}");
            AppendDocumentation(indentation, DocumentationTags.StandardMaths.Negate);
            Builder.Append($"{indentation}public {Data.Scalar.Name} Negate() => this;{Environment.NewLine}");
            AppendDocumentation(indentation, DocumentationTags.StandardMaths.Operators.UnaryPlus);
            Builder.Append($"{indentation}public static {Data.Scalar.Name} operator +({Data.Scalar.Name} x) => x;{Environment.NewLine}");
            AppendDocumentation(indentation, DocumentationTags.StandardMaths.Operators.Negate);
            Builder.Append($"{indentation}public static {Data.Scalar.Name} operator -({Data.Scalar.Name} x) => -x;{Environment.NewLine}");

            Builder.Append(Environment.NewLine);

            AppendDocumentation(indentation, DocumentationTags.StandardMaths.Multiply_Unhandled);
            Builder.Append($"{indentation}public Unhandled Multiply(Unhandled factor) => new(Magnitude.Value * factor.Magnitude.Value);{Environment.NewLine}");
            AppendDocumentation(indentation, DocumentationTags.StandardMaths.Divide_Unhandled);
            Builder.Append($"{indentation}public Unhandled Divide(Unhandled divisor) => new(Magnitude.Value / divisor.Magnitude.Value);{Environment.NewLine}");
            AppendDocumentation(indentation, DocumentationTags.StandardMaths.Operators.Multiply_Unhandled_LHS);
            Builder.Append($"{indentation}public static Unhandled operator *({Data.Scalar.Name} x, Unhandled y) => new(x.Magnitude.Value * y.Magnitude.Value);{Environment.NewLine}");
            AppendDocumentation(indentation, DocumentationTags.StandardMaths.Operators.Multiply_Unhandled_RHS);
            Builder.Append($"{indentation}public static Unhandled operator *(Unhandled x, {Data.Scalar.Name} y) => new(x.Magnitude.Value * y.Magnitude.Value);{Environment.NewLine}");
            AppendDocumentation(indentation, DocumentationTags.StandardMaths.Operators.Divide_Unhandled_LHS);
            Builder.Append($"{indentation}public static Unhandled operator /({Data.Scalar.Name} x, Unhandled y) => new(x.Magnitude.Value / y.Magnitude.Value);{Environment.NewLine}");
            AppendDocumentation(indentation, DocumentationTags.StandardMaths.Operators.Divide_Unhandled_RHS);
            Builder.Append($"{indentation}public static Unhandled operator /(Unhandled x, {Data.Scalar.Name} y) => new(x.Magnitude.Value / y.Magnitude.Value);{Environment.NewLine}");

            Builder.Append(Environment.NewLine);

            AppendDocumentation(indentation, DocumentationTags.StandardMaths.Remainder_Scalar);
            Builder.Append($"{indentation}public {Data.Scalar.Name} Remainder(Scalar divisor) => new(Magnitude.Value % divisor.Value);{Environment.NewLine}");
            AppendDocumentation(indentation, DocumentationTags.StandardMaths.Multiply_Scalar);
            Builder.Append($"{indentation}public {Data.Scalar.Name} Multiply(Scalar factor) => new(Magnitude.Value * factor.Value);{Environment.NewLine}");
            AppendDocumentation(indentation, DocumentationTags.StandardMaths.Divide_Scalar);
            Builder.Append($"{indentation}public {Data.Scalar.Name} Divide(Scalar divisor) => new(Magnitude.Value / divisor.Value);{Environment.NewLine}");
            AppendDocumentation(indentation, DocumentationTags.StandardMaths.Operators.Multiply_Scalar_LHS);
            Builder.Append($"{indentation}public static {Data.Scalar.Name} operator *({Data.Scalar.Name} x, Scalar y) => new(x.Magnitude.Value * y.Value);{Environment.NewLine}");
            AppendDocumentation(indentation, DocumentationTags.StandardMaths.Operators.Multiply_Scalar_RHS);
            Builder.Append($"{indentation}public static {Data.Scalar.Name} operator *(Scalar x, {Data.Scalar.Name} y) => new(x.Value * y.Magnitude.Value);{Environment.NewLine}");
            AppendDocumentation(indentation, DocumentationTags.StandardMaths.Operators.Divide_Scalar_LHS);
            Builder.Append($"{indentation}public static {Data.Scalar.Name} operator /({Data.Scalar.Name} x, Scalar y) => new(x.Magnitude.Value / y.Value);{Environment.NewLine}");

            Builder.Append(Environment.NewLine);

            AppendDocumentation(indentation, DocumentationTags.StandardMaths.Remainder_Double);
            Builder.Append($"{indentation}public {Data.Scalar.Name} Remainder(double divisor) => new(Magnitude.Value % divisor);{Environment.NewLine}");
            AppendDocumentation(indentation, DocumentationTags.StandardMaths.Multiply_Double);
            Builder.Append($"{indentation}public {Data.Scalar.Name} Multiply(double factor) => new(Magnitude.Value * factor);{Environment.NewLine}");
            AppendDocumentation(indentation, DocumentationTags.StandardMaths.Divide_Double);
            Builder.Append($"{indentation}public {Data.Scalar.Name} Divide(double divisor) => new(Magnitude.Value / divisor);{Environment.NewLine}");
            AppendDocumentation(indentation, DocumentationTags.StandardMaths.Operators.Multiply_Double_LHS);
            Builder.Append($"{indentation}public static {Data.Scalar.Name} operator *({Data.Scalar.Name} x, double y) => new(x.Magnitude.Value * y);{Environment.NewLine}");
            AppendDocumentation(indentation, DocumentationTags.StandardMaths.Operators.Multiply_Double_RHS);
            Builder.Append($"{indentation}public static {Data.Scalar.Name} operator *(double x, {Data.Scalar.Name} y) => new(x * y.Magnitude.Value);{Environment.NewLine}");
            AppendDocumentation(indentation, DocumentationTags.StandardMaths.Operators.Divide_Double_LHS);
            Builder.Append($"{indentation}public static {Data.Scalar.Name} operator /({Data.Scalar.Name} x, double y) => new(x.Magnitude.Value / y);{Environment.NewLine}");

            Builder.Append(Environment.NewLine);

            AppendDocumentation(indentation, DocumentationTags.StandardMaths.Multiply_Generic);
            Builder.Append($@"{indentation}public TProductScalar Multiply<TProductScalar, TFactorScalar>(TFactorScalar factor, Func<double, TProductScalar> factory)
{indentation}where TProductScalar : IScalar
{indentation}where TFactorScalar : IScalar
{indentation}{{
{indentation.Increased}ArgumentNullException.ThrowIfNull(factory, nameof(factory));
{indentation.Increased}ArgumentNullException.ThrowIfNull(factor, nameof(factor));

{indentation.Increased}return factory(Magnitude.Value * factor.Magnitude.Value);

{indentation}}}

");

            AppendDocumentation(indentation, DocumentationTags.StandardMaths.Divide_Generic);
            Builder.Append($@"{indentation}public TProductScalar Divide<TQuotientScalar, TDivisorScalar>(TDivisorScalar divisor, Func<double, TQuotientScalar> factory)
{indentation}where TQuotientScalar : IScalar
{indentation}where TDivisorScalar : IScalar
{indentation}{{
{indentation.Increased}ArgumentNullException.ThrowIfNull(factory, nameof(factory));
{indentation.Increased}ArgumentNullException.ThrowIfNull(divisor, nameof(divisor));

{indentation.Increased}return factory(Magnitude.Value / divisor.Magnitude.Value);

{indentation}}}

");
            AppendDocumentation(indentation, DocumentationTags.StandardMaths.Multiply_IScalar);
            Builder.Append($@"{indentation}public static Unhandled operator *({Data.Scalar.Name} x, IScalar y)
{indentation}{{
{indentation.Increased}ArgumentNullException.ThrowIfNull(y, nameof(y));

{indentation.Increased}return new Unhandled(x.Magnitude.Value * y.Magnitude.Value);{Environment.NewLine}
{indentation}}}
            
");

            AppendDocumentation(indentation, DocumentationTags.StandardMaths.Divide_IScalar);
            Builder.Append($@"{indentation}public static Unhandled operator /({Data.Scalar.Name} x, IScalar y)
{indentation}{{
{indentation.Increased}ArgumentNullException.ThrowIfNull(y, nameof(y));

{indentation.Increased}return new Unhandled(x.Magnitude.Value / y.Magnitude.Value);{Environment.NewLine}
{indentation}}}
            
");
        }

        private void AppendDocumentation(Indentation indentation, string tag)
        {
            DocumentationBuilding.AppendDocumentation(Context, Builder, Data.Documentation, indentation, tag);
        }
    }
}
