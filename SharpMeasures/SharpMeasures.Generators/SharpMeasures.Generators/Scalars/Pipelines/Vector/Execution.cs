namespace SharpMeasures.Generators.Scalars.Pipelines.Vector;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

using SharpMeasures.Generators.SourceBuilding;
using SharpMeasures.Generators.Vectors;

using System;
using System.Collections.Generic;
using System.Text;

internal static class Execution
{
    public static void Execute(SourceProductionContext context, DataModel data)
    {
        string source = Composer.Compose(context, data);

        context.AddSource($"{data.Scalar.Name}_Vector.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private class Composer
    {
        public static string Compose(SourceProductionContext context, DataModel data)
        {
            Composer composer = new(context, data);
            composer.Compose();
            composer.ReportDiagnostics();
            return composer.Retrieve();
        }

        private SourceProductionContext Context { get; }
        private StringBuilder Builder { get; } = new();

        private DataModel Data { get; }

        private UsingsCollector UsingsCollector { get; }
        private List<Diagnostic> Diagnostics { get; } = new();

        private static VectorTexts DoubleTupleText { get; } = VectorTexts.CommaSeparatedElements_LowerCased("double");
        private static VectorTexts ScalarTupleText { get; } = VectorTexts.CommaSeparatedElements_LowerCased("Scalar");

        private Composer(SourceProductionContext context, DataModel data)
        {
            Context = context;
            Data = data;

            UsingsCollector = UsingsCollector.Delayed(Builder, data.Scalar.Namespace);
            UsingsCollector.AddUsing("SharpMeasures");
        }

        private void Compose()
        {
            StaticBuilding.AppendAutoGeneratedHeader(Builder);
            StaticBuilding.AppendNullableDirective(Builder);

            NamespaceBuilding.AppendNamespace(Builder, Data.Scalar.Namespace);

            UsingsCollector.MarkInsertionPoint();

            Builder.Append(Data.Scalar.ComposeDeclaration());

            BlockBuilding.AppendBlock(Builder, ComposeTypeBlock, originalIndentationLevel: 0);

            UsingsCollector.InsertUsings();
        }

        private void ReportDiagnostics()
        {
            Context.ReportDiagnostics(Diagnostics);
        }

        private string Retrieve()
        {
            return Builder.ToString();
        }

        private void ComposeTypeBlock(Indentation indentation)
        {
            foreach (VectorInterface vector in Data.VectorCollection.Vectors)
            {
                UsingsCollector.AddUsing(vector.VectorType.Namespace);

                ComposeForVector(indentation, vector);
                Builder.AppendLine();
            }
        }

        private void ComposeForVector(Indentation indentation, VectorInterface vector)
        {
            string doubleTuple = $"({DoubleTupleText.GetText(vector.Dimension)}";
            string scalarTuple = $"({ScalarTupleText.GetText(vector.Dimension)}";

            AppendDocumentation(indentation, ScalarDocumentationTags.Vectors.Multiply_Vector(vector.Dimension));
            Builder.Append($"{indentation}public {vector.VectorType.Name} Multiply(Vector{vector.Dimension} factor) => new(Magnitude.Value * factor);{Environment.NewLine}");

            AppendDocumentation(indentation, ScalarDocumentationTags.Vectors.Multiply_DoubleTuple(vector.Dimension));
            Builder.Append($"{indentation}public {vector.VectorType.Name} Multiply({doubleTuple} components) => new(Magnitude * components);{Environment.NewLine}");

            AppendDocumentation(indentation, ScalarDocumentationTags.Vectors.Multiply_ScalarTuple(vector.Dimension));
            Builder.Append($"{indentation}public {vector.VectorType.Name} Multiply({scalarTuple} components) => new(Magnitude * components);{Environment.NewLine}");

            Builder.AppendLine();

            AppendDocumentation(indentation, ScalarDocumentationTags.Vectors.Operators.Multiply_Vector_LHS(vector.Dimension));
            Builder.Append($"{indentation}public static {vector.VectorType.Name} operator *({Data.Scalar.Name} x, Vector{vector.Dimension} y) => new(x.Magnitude.Value * y);{Environment.NewLine}");

            AppendDocumentation(indentation, ScalarDocumentationTags.Vectors.Operators.Multiply_Vector_RHS(vector.Dimension));
            Builder.Append($"{indentation}public static {vector.VectorType.Name} operator *(Vector{vector.Dimension} x, {Data.Scalar.Name} y) => new(x * y.Magnitude.Value);{Environment.NewLine}");

            AppendDocumentation(indentation, ScalarDocumentationTags.Vectors.Operators.Multiply_DoubleTuple_LHS(vector.Dimension));
            Builder.Append($"{indentation}public static {vector.VectorType.Name} operator *({Data.Scalar.Name} x, {doubleTuple} y) => new(x.Magnitude * y);{Environment.NewLine}");

            AppendDocumentation(indentation, ScalarDocumentationTags.Vectors.Operators.Multiply_DoubleTuple_RHS(vector.Dimension));
            Builder.Append($"{indentation}public static {vector.VectorType.Name} operator *({doubleTuple} x, {Data.Scalar.Name} y) => new(x * y.Magnitude);{Environment.NewLine}");

            AppendDocumentation(indentation, ScalarDocumentationTags.Vectors.Operators.Multiply_ScalarTuple_LHS(vector.Dimension));
            Builder.Append($"{indentation}public static {vector.VectorType.Name} operator *({Data.Scalar.Name} x, {scalarTuple} y) => new(x.Magnitude * y);{Environment.NewLine}");

            AppendDocumentation(indentation, ScalarDocumentationTags.Vectors.Operators.Multiply_ScalarTuple_RHS(vector.Dimension));
            Builder.Append($"{indentation}public static {vector.VectorType.Name} operator *({scalarTuple} x, {Data.Scalar.Name} y) => new(x * y.Magnitude);{Environment.NewLine}");
        }

        private void AppendDocumentation(Indentation indentation, string tag)
        {
            DocumentationBuilding.AppendDocumentation(Context, Builder, Data.Documentation, indentation, tag);
        }
    }
}
