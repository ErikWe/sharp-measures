namespace SharpMeasures.Generators.Scalars.Pipelines.Vector;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

using SharpMeasures.Generators.SourceBuilding;
using SharpMeasures.Generators.Vectors;

using System;
using System.Collections.Generic;
using System.Text;

internal static class Execution
{
    public static void Execute(SourceProductionContext context, DataModel data)
    {
        string source = Composer.Compose(context, data);

        context.AddSource($"{data.Scalar.Name}_Vector.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private class Composer
    {
        public static string Compose(SourceProductionContext context, DataModel data)
        {
            Composer composer = new(context, data);
            composer.Compose();
            composer.ReportDiagnostics();
            return composer.Retrieve();
        }

        private SourceProductionContext Context { get; }
        private StringBuilder Builder { get; } = new();

        private DataModel Data { get; }

        private UsingsCollector UsingsCollector { get; }
        private List<Diagnostic> Diagnostics { get; } = new();

        private Composer(SourceProductionContext context, DataModel data)
        {
            Context = context;
            Data = data;

            UsingsCollector = UsingsCollector.Delayed(Builder, data.Scalar.Namespace);
            UsingsCollector.AddUsing("SharpMeasures");
        }

        private void Compose()
        {
            StaticBuilding.AppendAutoGeneratedHeader(Builder);
            StaticBuilding.AppendNullableDirective(Builder);

            NamespaceBuilding.AppendNamespace(Builder, Data.Scalar.Namespace);

            UsingsCollector.MarkInsertionPoint();

            Builder.Append(Data.Scalar.ComposeDeclaration());

            BlockBuilding.AppendBlock(Builder, ComposeTypeBlock, originalIndentationLevel: 0);

            UsingsCollector.InsertUsings();
        }

        private void ReportDiagnostics()
        {
            Context.ReportDiagnostics(Diagnostics);
        }

        private string Retrieve()
        {
            return Builder.ToString();
        }

        private void ComposeTypeBlock(Indentation indentation)
        {
            foreach (VectorInterface vector in Data.VectorCollection.Vectors)
            {
                UsingsCollector.AddUsing(vector.VectorType.Namespace);

                ComposeForVector(indentation, vector);
                Builder.Append(Environment.NewLine);
            }
        }

        private void ComposeForVector(Indentation indentation, VectorInterface vector)
        {
            string doubleTuple = TupleTexts.GetDoubleTupleText(vector.Dimension);
            string scalarTuple = TupleTexts.GetScalarTupleText(vector.Dimension);

            AppendDocumentation(indentation, ScalarDocumentationTags.Vectors.Multiply_Vector(vector.Dimension));
            Builder.Append($"{indentation}public {vector.VectorType.Name} Multiply(Vector{vector.Dimension} factor) => new(Magnitude.Value * factor);{Environment.NewLine}");

            AppendDocumentation(indentation, ScalarDocumentationTags.Vectors.Multiply_DoubleTuple(vector.Dimension));
            Builder.Append($"{indentation}public {vector.VectorType.Name} Multiply({doubleTuple} components) => new(Magnitude * components);{Environment.NewLine}");

            AppendDocumentation(indentation, ScalarDocumentationTags.Vectors.Multiply_ScalarTuple(vector.Dimension));
            Builder.Append($"{indentation}public {vector.VectorType.Name} Multiply({scalarTuple} components) => new(Magnitude * components);{Environment.NewLine}");

            Builder.Append(Environment.NewLine);

            AppendDocumentation(indentation, ScalarDocumentationTags.Vectors.Operators.Multiply_Vector_LHS(vector.Dimension));
            Builder.Append($"{indentation}public static {vector.VectorType.Name} operator *({Data.Scalar.Name} x, Vector{vector.Dimension} y) => new(x.Magnitude.Value * y);{Environment.NewLine}");

            AppendDocumentation(indentation, ScalarDocumentationTags.Vectors.Operators.Multiply_Vector_RHS(vector.Dimension));
            Builder.Append($"{indentation}public static {vector.VectorType.Name} operator *(Vector{vector.Dimension} x, {Data.Scalar.Name} y) => new(x * y.Magnitude.Value);{Environment.NewLine}");

            AppendDocumentation(indentation, ScalarDocumentationTags.Vectors.Operators.Multiply_DoubleTuple_LHS(vector.Dimension));
            Builder.Append($"{indentation}public static {vector.VectorType.Name} operator *({Data.Scalar.Name} x, {doubleTuple} y) => new(x.Magnitude * y);{Environment.NewLine}");

            AppendDocumentation(indentation, ScalarDocumentationTags.Vectors.Operators.Multiply_DoubleTuple_RHS(vector.Dimension));
            Builder.Append($"{indentation}public static {vector.VectorType.Name} operator *({doubleTuple} x, {Data.Scalar.Name} y) => new(x * y.Magnitude);{Environment.NewLine}");

            AppendDocumentation(indentation, ScalarDocumentationTags.Vectors.Operators.Multiply_ScalarTuple_LHS(vector.Dimension));
            Builder.Append($"{indentation}public static {vector.VectorType.Name} operator *({Data.Scalar.Name} x, {scalarTuple} y) => new(x.Magnitude * y);{Environment.NewLine}");

            AppendDocumentation(indentation, ScalarDocumentationTags.Vectors.Operators.Multiply_ScalarTuple_RHS(vector.Dimension));
            Builder.Append($"{indentation}public static {vector.VectorType.Name} operator *({scalarTuple} x, {Data.Scalar.Name} y) => new(x * y.Magnitude);{Environment.NewLine}");
        }

        private void AppendDocumentation(Indentation indentation, string tag)
        {
            DocumentationBuilding.AppendDocumentation(Context, Builder, Data.Documentation, indentation, tag);
        }

        private static class TupleTexts
        {
            private static Dictionary<int, string> DoubleTupleTexts { get; } = new();
            private static Dictionary<int, string> ScalarTupleTexts { get; } = new();

            public static string GetDoubleTupleText(int cardinality) => GetOrComposeTupleText(cardinality, "double", DoubleTupleTexts);
            public static string GetScalarTupleText(int cardinality) => GetOrComposeTupleText(cardinality, "Scalar", ScalarTupleTexts);

            private static string GetOrComposeTupleText(int cardinality, string type, Dictionary<int, string> cache)
            {
                if (cache.TryGetValue(cardinality, out var text))
                {
                    return text;
                }

                text = ComposeTupleText(type, cardinality);
                cache.Add(cardinality, text);
                return text;
            }

            private static string ComposeTupleText(string type, int cardinality)
            {
                StringBuilder source = new();
                IterativeBuilding.AppendEnumerable(source, "(", components(), ", ", ")");
                return source.ToString();

                IEnumerable<string> components()
                {
                    for (int i = 0; i < cardinality; i++)
                    {
                        yield return type;
                    }
                }
            }
        }
    }
}
