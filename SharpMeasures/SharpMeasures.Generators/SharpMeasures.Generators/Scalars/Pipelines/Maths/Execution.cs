namespace SharpMeasures.Generators.Scalars.Pipelines.Maths;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

using SharpMeasures.Generators.SourceBuilding;

using System;
using System.Text;

internal static class Execution
{
    public static void Execute(SourceProductionContext context, DataModel data)
    {
        string source = Composer.Compose(context, data);

        context.AddSource($"{data.Scalar.Name}_Maths.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private class Composer
    {
        public static string Compose(SourceProductionContext context, DataModel data)
        {
            Composer composer = new(context, data);
            composer.Compose();
            return composer.Retrieve();
        }

        private SourceProductionContext Context { get; }
        private StringBuilder Builder { get; } = new();

        private DataModel Data { get; }

        private UsingsCollector UsingsCollector { get; }
        private InterfaceCollector InterfaceCollector { get; }

        private Composer(SourceProductionContext context, DataModel data)
        {
            Context = context;
            Data = data;

            UsingsCollector = UsingsCollector.Delayed(Builder, data.Scalar.Namespace);
            InterfaceCollector = InterfaceCollector.Delayed(Builder);

            UsingsCollector.AddUsings("SharpMeasures", "SharpMeasures.ScalarAbstractions");
            InterfaceCollector.AddInterfaces(new []
            {
                $"IScalableScalar<{Data.Scalar.Name}>",
                $"IMultiplicableScalar<{Data.Scalar.Name}, Scalar>",
                "IMultiplicableScalar<Unhandled, Unhandled>",
                $"IDivisibleScalar<{Data.Scalar.Name}, Scalar>",
                $"IDivisibleScalar<Scalar, {Data.Scalar.Name}>",
                "IDivisibleScalarQuantity<Unhandled, Unhandled>"
            });
        }

        private void Compose()
        {
            StaticBuilding.AppendAutoGeneratedHeader(Builder);
            StaticBuilding.AppendNullableDirective(Builder);

            NamespaceBuilding.AppendNamespace(Builder, Data.Scalar.Namespace);

            UsingsCollector.MarkInsertionPoint();

            Builder.Append(Data.Scalar.ComposeDeclaration());

            InterfaceCollector.MarkInsertionPoint();

            BlockBuilding.AppendBlock(Builder, ComposeTypeBlock, originalIndentationLevel: 0);

            InterfaceCollector.InsertInterfaces();
            UsingsCollector.InsertUsings();
        }

        private string Retrieve()
        {
            return Builder.ToString();
        }

        private void ComposeTypeBlock(Indentation indentation)
        {
            AppendDocumentation(indentation, ScalarDocumentationTags.StandardMaths.IsNaN);
            Builder.AppendLine($"{indentation}public bool IsNaN => double.IsNaN(Magnitude.Value)");
            AppendDocumentation(indentation, ScalarDocumentationTags.StandardMaths.IsZero);
            Builder.AppendLine($"{indentation}public bool IsZero => Magnitude.Value is 0;");
            AppendDocumentation(indentation, ScalarDocumentationTags.StandardMaths.IsPositive);
            Builder.AppendLine($"{indentation}public bool IsPositive => Magnitude.Value > 0;");
            AppendDocumentation(indentation, ScalarDocumentationTags.StandardMaths.IsNegative);
            Builder.AppendLine($"{indentation}public bool IsNegative => Magnitude.Value < 0;");
            AppendDocumentation(indentation, ScalarDocumentationTags.StandardMaths.IsFinite);
            Builder.AppendLine($"{indentation}public bool IsFinite => double.IsFinite(Magnitude.Value);");
            AppendDocumentation(indentation, ScalarDocumentationTags.StandardMaths.IsInfinity);
            Builder.AppendLine($"{indentation}public bool IsInfinite => double.IsInfinity(Magnitude.Value);");
            AppendDocumentation(indentation, ScalarDocumentationTags.StandardMaths.IsPositiveInfinity);
            Builder.AppendLine($"{indentation}public bool IsPositiveInfinity => double.IsPositiveInfinity(Magnitude.Value);");
            AppendDocumentation(indentation, ScalarDocumentationTags.StandardMaths.IsNegativeInfinity);
            Builder.AppendLine($"{indentation}public bool IsNegativeInfinity => double.IsNegativeInfinity(Magnitude.Value);");

            Builder.AppendLine();

            AppendDocumentation(indentation, ScalarDocumentationTags.StandardMaths.Absolute);
            Builder.AppendLine($"{indentation}public {Data.Scalar.Name} Absolute() => new(Math.Abs(Magnitude.Value));");
            AppendDocumentation(indentation, ScalarDocumentationTags.StandardMaths.Floor);
            Builder.AppendLine($"{indentation}public {Data.Scalar.Name} Floor() => new(Math.Floor(Magnitude.Value));");
            AppendDocumentation(indentation, ScalarDocumentationTags.StandardMaths.Ceiling);
            Builder.AppendLine($"{indentation}public {Data.Scalar.Name} Ceiling() => new(Math.Ceiling(Magnitude.Value));");
            AppendDocumentation(indentation, ScalarDocumentationTags.StandardMaths.Round);
            Builder.AppendLine($"{indentation}public {Data.Scalar.Name} Round() => new(Math.Round(Magnitude.Value));");
            AppendDocumentation(indentation, ScalarDocumentationTags.StandardMaths.Truncate);
            Builder.AppendLine($"{indentation}public {Data.Scalar.Name} Truncate() => new(Math.Truncate(Magnitude.Value));");

            Builder.AppendLine();

            AppendDocumentation(indentation, ScalarDocumentationTags.StandardMaths.Sign);
            Builder.AppendLine($"public int Sign() => Math.Sign(Magnitude.Value);");

            Builder.AppendLine();

            AppendPowerFunctions(indentation);

            AppendFromPowerFunctions(indentation);

            AppendDocumentation(indentation, ScalarDocumentationTags.StandardMaths.UnaryPlus);
            Builder.AppendLine($"{indentation}public {Data.Scalar.Name} Plus() => this;");
            AppendDocumentation(indentation, ScalarDocumentationTags.StandardMaths.Negate);
            Builder.AppendLine($"{indentation}public {Data.Scalar.Name} Negate() => this;");
            AppendDocumentation(indentation, ScalarDocumentationTags.StandardMaths.Operators.UnaryPlus);
            Builder.AppendLine($"{indentation}public static {Data.Scalar.Name} operator +({Data.Scalar.Name} x) => x;");
            AppendDocumentation(indentation, ScalarDocumentationTags.StandardMaths.Operators.Negate);
            Builder.AppendLine($"{indentation}public static {Data.Scalar.Name} operator -({Data.Scalar.Name} x) => -x;");

            Builder.AppendLine();

            if (Data.Square is not null)
            {
                InterfaceCollector.AddInterfaces($"IMultiplicableScalar<{Data.Square.Value.Name}, {Data.Scalar.Name}>");

                AppendDocumentation(indentation, ScalarDocumentationTags.StandardMaths.Multiply_SameType);
                Builder.AppendLine($"{indentation}public {Data.Square.Value.Name} Multiply({Data.Scalar.Name} factor) => new(Magnitude.Value * factor.Magnitude.Value);");
                AppendDocumentation(indentation, ScalarDocumentationTags.StandardMaths.Operators.Multiply_SameType);
                Builder.AppendLine($"{indentation}public static {Data.Square.Value.Name} operator *({Data.Scalar.Name} x, {Data.Scalar.Name} y) => new(x.Magnitude.Value * y.Magnitude.Value);");
                
                Builder.AppendLine();
            }

            AppendDocumentation(indentation, ScalarDocumentationTags.StandardMaths.Divide_SameType);
            Builder.AppendLine($"{indentation}public Scalar Divide({Data.Scalar.Name} divisor) => new(Magnitude.Value / divisor.Magnitude.Value);");
            AppendDocumentation(indentation, ScalarDocumentationTags.StandardMaths.Operators.Divide_SameType);
            Builder.AppendLine($"{indentation}public static Scalar operator /({Data.Scalar.Name} x, {Data.Scalar.Name} y) => new(x.Magnitude.Value / y.Magnitude.Value);");

            Builder.AppendLine();

            AppendDocumentation(indentation, ScalarDocumentationTags.StandardMaths.Remainder_Scalar);
            Builder.AppendLine($"{indentation}public {Data.Scalar.Name} Remainder(Scalar divisor) => new(Magnitude.Value % divisor.Value);");
            AppendDocumentation(indentation, ScalarDocumentationTags.StandardMaths.Multiply_Scalar);
            Builder.AppendLine($"{indentation}public {Data.Scalar.Name} Multiply(Scalar factor) => new(Magnitude.Value * factor.Value);");
            AppendDocumentation(indentation, ScalarDocumentationTags.StandardMaths.Divide_Scalar);
            Builder.AppendLine($"{indentation}public {Data.Scalar.Name} Divide(Scalar divisor) => new(Magnitude.Value / divisor.Value);");
            AppendDocumentation(indentation, ScalarDocumentationTags.StandardMaths.Operators.Multiply_Scalar_LHS);
            Builder.AppendLine($"{indentation}public static {Data.Scalar.Name} operator *({Data.Scalar.Name} x, Scalar y) => new(x.Magnitude.Value * y.Value);");
            AppendDocumentation(indentation, ScalarDocumentationTags.StandardMaths.Operators.Multiply_Scalar_RHS);
            Builder.AppendLine($"{indentation}public static {Data.Scalar.Name} operator *(Scalar x, {Data.Scalar.Name} y) => new(x.Value * y.Magnitude.Value);");
            AppendDocumentation(indentation, ScalarDocumentationTags.StandardMaths.Operators.Divide_Scalar_LHS);
            Builder.AppendLine($"{indentation}public static {Data.Scalar.Name} operator /({Data.Scalar.Name} x, Scalar y) => new(x.Magnitude.Value / y.Value);");

            if (Data.Reciprocal is not null)
            {
                AppendDocumentation(indentation, ScalarDocumentationTags.StandardMaths.Operators.Divide_Scalar_RHS);
                Builder.AppendLine($"{indentation}public static {Data.Reciprocal.Value.Name} operator /(Scalar x, {Data.Scalar.Name} y) => new(x.Value / y.Magnitude.Value);");
            }

            Builder.AppendLine();

            AppendDocumentation(indentation, ScalarDocumentationTags.StandardMaths.Multiply_IScalar);
            Builder.AppendLine($"{indentation}public static Unhandled operator *({Data.Scalar.Name} x, IScalar y)");
            BlockBuilding.AppendBlock(Builder, composeIScalarMultiplicationBlock, indentation);

            void composeIScalarMultiplicationBlock(Indentation indentation)
            {
                Builder.AppendLine($"{indentation}ArgumentNullException.ThrowIfNull(y, nameof(y))");
                Builder.AppendLine();
                Builder.AppendLine($"{indentation}return new Unhandled(x.Magnitude.Value * y.Magnitude.Value);");
            }

            AppendDocumentation(indentation, ScalarDocumentationTags.StandardMaths.Divide_IScalar);
            Builder.AppendLine($"{indentation}public static Unhandled operator /({Data.Scalar.Name} x, IScalar y)");
            BlockBuilding.AppendBlock(Builder, composeIScalarDivisionBlock, indentation);

            void composeIScalarDivisionBlock(Indentation indentation)
            {
                Builder.AppendLine($"{indentation}ArgumentNullException.ThrowIfNull(y, nameof(y))");
                Builder.AppendLine();
                Builder.AppendLine($"{indentation}return new Unhandled(x.Magnitude.Value / y.Magnitude.Value);");
            }
        }

        private void AppendPowerFunctions(Indentation indentation)
        {
            int startLength = Builder.Length;

            if (Data.Reciprocal is not null)
            {
                UsingsCollector.AddUsing(Data.Reciprocal.Value.Namespace);

                AppendDocumentation(indentation, ScalarDocumentationTags.StandardMaths.Reciprocal);
                Builder.AppendLine($"{indentation}public {Data.Reciprocal.Value.Name} Reciprocal() => new(1 / Magnitude.Value);");
            }

            if (Data.Square is not null)
            {
                UsingsCollector.AddUsing(Data.Square.Value.Namespace);
                UsingsCollector.AddUsing("System");

                AppendDocumentation(indentation, ScalarDocumentationTags.StandardMaths.Square);
                Builder.AppendLine($"{indentation}public {Data.Square.Value.Name} Square() => new(Math.Pow(Magnitude.Value, 2));");
            }

            if (Data.Cube is not null)
            {
                UsingsCollector.AddUsing(Data.Cube.Value.Namespace);
                UsingsCollector.AddUsing("System");

                AppendDocumentation(indentation, ScalarDocumentationTags.StandardMaths.Cube);
                Builder.AppendLine($"{indentation}public {Data.Cube.Value.Name} Cube() => new(Math.Pow(Magnitude.Value, 3));");
            }

            if (Data.SquareRoot is not null)
            {
                UsingsCollector.AddUsing(Data.SquareRoot.Value.Namespace);
                UsingsCollector.AddUsing("System");

                AppendDocumentation(indentation, ScalarDocumentationTags.StandardMaths.SquareRoot);
                Builder.AppendLine($"{indentation}public {Data.SquareRoot.Value.Name} SquareRoot() => new(Math.Sqrt(Magnitude.Value));");
            }

            if (Data.CubeRoot is not null)
            {
                UsingsCollector.AddUsing(Data.CubeRoot.Value.Namespace);
                UsingsCollector.AddUsing("System");

                AppendDocumentation(indentation, ScalarDocumentationTags.StandardMaths.CubeRoot);
                Builder.AppendLine($"{indentation}public {Data.CubeRoot.Value.Name} CubeRoot() => new(Math.Cbrt(Magnitude.Value));");
            }

            if (Builder.Length > startLength)
            {
                Builder.AppendLine();
            }
        }

        private void AppendFromPowerFunctions(Indentation indentation)
        {
            int startLength = Builder.Length;

            if (Data.Reciprocal is not null)
            {
                string parameterName = SourceBuildingUtility.ToParameterName(Data.Reciprocal.Value.Name);

                AppendDocumentation(indentation, ScalarDocumentationTags.StandardMaths.FromReciprocal);
                Builder.AppendLine($"{indentation}public {Data.Scalar.Name} From({Data.Reciprocal.Value.Name} {parameterName}) => " +
                    $"new(1 / {parameterName}.Magnitude.Value);");
            }

            if (Data.Square is not null)
            {
                string parameterName = SourceBuildingUtility.ToParameterName(Data.Square.Value.Name);

                AppendDocumentation(indentation, ScalarDocumentationTags.StandardMaths.FromSquare);
                Builder.AppendLine($"{indentation}public {Data.Scalar.Name} From({Data.Square.Value.Name} {parameterName}) => " +
                    $"new(Math.Sqrt({parameterName}.Magnitude.Value));");
            }

            if (Data.Cube is not null)
            {
                string parameterName = SourceBuildingUtility.ToParameterName(Data.Cube.Value.Name);

                AppendDocumentation(indentation, ScalarDocumentationTags.StandardMaths.FromCube);
                Builder.AppendLine($"{indentation}public {Data.Scalar.Name} From({Data.Cube.Value.Name} {parameterName}) => " +
                    $"new(Math.Cbrt({parameterName}.Magnitude.Value));");
            }

            if (Data.SquareRoot is not null)
            {
                string parameterName = SourceBuildingUtility.ToParameterName(Data.SquareRoot.Value.Name);

                AppendDocumentation(indentation, ScalarDocumentationTags.StandardMaths.FromSquareRoot);
                Builder.AppendLine($"{indentation}public {Data.Scalar.Name} From({Data.SquareRoot.Value.Name} {parameterName}) => " +
                    $"new(Math.Pow({parameterName}.Magnitude.Value, 2));");
            }

            if (Data.CubeRoot is not null)
            {
                string parameterName = SourceBuildingUtility.ToParameterName(Data.CubeRoot.Value.Name);

                AppendDocumentation(indentation, ScalarDocumentationTags.StandardMaths.FromCubeRoot);
                Builder.AppendLine($"{indentation}public {Data.Scalar.Name} From({Data.CubeRoot.Value.Name} {parameterName}) => " +
                    $"new(Math.Pow({parameterName}.Magnitude.Value, 3));");
            }

            if (Builder.Length > startLength)
            {
                Builder.AppendLine();
            }
        }

        private void AppendDocumentation(Indentation indentation, string tag)
        {
            DocumentationBuilding.AppendDocumentation(Context, Builder, Data.Documentation, indentation, tag);
        }
    }
}
