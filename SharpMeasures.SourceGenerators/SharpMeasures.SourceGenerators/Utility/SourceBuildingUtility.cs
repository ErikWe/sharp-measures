namespace ErikWe.SharpMeasures.SourceGenerators.Utility;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Reflection;
using System.Text;

internal static class SourceBuildingUtility
{
    public static void AppendEnumerable(StringBuilder source, IEnumerable<string> texts, string separator)
        => AppendEnumerable(source, string.Empty, texts, separator, string.Empty);

    public static void AppendEnumerable(StringBuilder source, string prefix, IEnumerable<string> texts, string separator)
        => AppendEnumerable(source, prefix, texts, separator, string.Empty);

    public static void AppendEnumerable(StringBuilder source, IEnumerable<string> texts, string separator, string postfix)
        => AppendEnumerable(source, string.Empty, texts, separator, postfix);

    public static void AppendEnumerable(StringBuilder source, string prefix, IEnumerable<string> texts, string separator, string postfix)
    {
        source.Append(prefix);

        bool anyTexts = false;
        foreach (string text in texts)
        {
            anyTexts = true;
            source.Append(text + separator);
        }

        if (anyTexts)
        {
            source.Remove(source.Length - separator.Length, separator.Length);
            source.Append(postfix);
        }
        else
        {
            source.Remove(source.Length - prefix.Length, prefix.Length);
        }
    }

    public static void AppendAutoGeneratedHeader(StringBuilder source)
    {
        source.Append($@"//----------------------
// <auto-generated>
//      This file was generated by {Assembly.GetExecutingAssembly().GetName().Name} v{Assembly.GetExecutingAssembly().GetName().Version} ({DateTime.UtcNow} UTC).
//
//      Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>
//----------------------

");
    }

    public static void AppendNullableDirective(StringBuilder source)
    {
        source.Append($"#nullable enable{Environment.NewLine}{Environment.NewLine}");
    }

    public static void AppendNamespace(StringBuilder source, ISymbol symbol)
    {
        if (symbol.ContainingNamespace?.ToDisplayString() is string namespaceName)
        {
            source.Append($"namespace {namespaceName};{Environment.NewLine}{Environment.NewLine}");
        }
    }

    public static void AppendUsings(StringBuilder source, ISymbol symbol, IEnumerable<string> usingsNames)
    {
        string implicitUsing = symbol.ContainingNamespace?.ToDisplayString() ?? string.Empty;

        AppendEnumerable(source, toLines(), string.Empty, Environment.NewLine);

        IEnumerable<string> toLines()
        {
            foreach (string usingName in usingsNames)
            {
                if (!implicitUsing.StartsWith(usingName, StringComparison.Ordinal))
                {
                    yield return $"using {usingName};{Environment.NewLine}";
                }
            }
        }
    }

    public static void AppendUsings(StringBuilder source, IEnumerable<string> usingsNames)
    {
        bool anyUsings = false;

        foreach (string usingName in usingsNames)
        {
            anyUsings = true;
            source.Append($"using {usingName};{Environment.NewLine}");
        }

        if (anyUsings)
        {
            source.Append(Environment.NewLine);
        }    
    }

    public static void AppendTypeDefinition(StringBuilder source, ITypeSymbol symbol)
    {
        string accessibilityText = symbol.DeclaredAccessibility switch
        {
            Accessibility.NotApplicable => SyntaxFacts.GetText(Accessibility.Private),
            _ => SyntaxFacts.GetText(symbol.DeclaredAccessibility)
        };

        string readonlyText = symbol.IsReadOnly ? " readonly" : string.Empty;
        string recordText = symbol.IsRecord ? "record " : string.Empty;
        string typeText = symbol.IsValueType ? "struct" : "class";

        source.Append($"{accessibilityText}{readonlyText} partial {recordText}{typeText} {symbol.Name}");
    }

    public static void AppendInterfaceImplementation(StringBuilder source, IEnumerable<INamedTypeSymbol> interfaceSymbols)
    {
        AppendInterfaceImplementation(source, symbolsToDisplayStrings());

        IEnumerable<string> symbolsToDisplayStrings()
        {
            foreach (INamedTypeSymbol interfaceSymbol in interfaceSymbols)
            {
                yield return interfaceSymbol.ToDisplayString();
            }
        }
    }

    public static void AppendInterfaceImplementation(StringBuilder source, IEnumerable<string> interfaceStrings)
        => AppendEnumerable(source, " : ", interfaceStrings, ", ");

    public static string GetIndentationString(int level)
    {
        string text = "";
        for (int i = 0; i < level; i++)
        {
            text += "\t";
        }

        return text;
    }

    public static void AppendBlock(StringBuilder source, Action<StringBuilder, string> blockContentAppender, int indentLevel = 0,
        bool initialNewLine = true, bool finalNewLine = true)
    {
        AppendOpeningBracket(source, indentLevel, initialNewLine, finalNewLine: true);
        blockContentAppender(source, GetIndentationString(indentLevel + 1));
        AppendClosingBracket(source, indentLevel, initialNewLine: !source.ToString().EndsWith(Environment.NewLine, StringComparison.Ordinal), finalNewLine);
    }

    public static void AppendOpeningBracket(StringBuilder source, int indentLevel = 0, bool initialNewLine = true, bool finalNewLine = true)
    {
        if (initialNewLine)
        {
            source.Append(Environment.NewLine);
        }

        source.Append($"{GetIndentationString(indentLevel)}{{");

        if (finalNewLine)
        {
            source.Append(Environment.NewLine);
        }
    }

    public static void AppendClosingBracket(StringBuilder source, int indentLevel = 0, bool initialNewLine = false, bool finalNewLine = false)
    {
        if (initialNewLine)
        {
            source.Append(Environment.NewLine);
        }

        source.Append($"{GetIndentationString(indentLevel)}}}");

        if (finalNewLine)
        {
            source.Append(Environment.NewLine);
        }
    }

    public static string ToParameterName(string name) => name.Substring(0, 1).ToLower(CultureInfo.CurrentCulture) + name.Substring(1);
}
